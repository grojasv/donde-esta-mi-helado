---
// Import global styles with Tailwind CSS
import '../styles/global.css';
// Import the reusable IceCreamContainer component
import IceCreamContainer from '../components/IceCreamContainer.astro';

// Get git commit information for version tracking
import { execSync } from 'child_process';

let gitInfo = {
	hash: 'unknown',
	message: 'Local build',
	date: new Date().toISOString(),
	branch: 'unknown'
};

try {
	// Get current commit hash (short)
	gitInfo.hash = execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).trim();
	
	// Get commit message
	gitInfo.message = execSync('git log -1 --pretty=%s', { encoding: 'utf-8' }).trim();
	
	// Get commit date
	gitInfo.date = execSync('git log -1 --pretty=%cI', { encoding: 'utf-8' }).trim();
	
	// Get current branch
	gitInfo.branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
} catch (error) {
	console.warn('Could not get git information:', error.message);
}

// Format build timestamp
const buildTime = new Date().toISOString();

// Get Firebase environment variables for client-side use
// These will be passed to the browser as inline JavaScript variables
const firebaseEnvVars = {
	apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY || null,
	authDomain: import.meta.env.PUBLIC_FIREBASE_AUTH_DOMAIN || null,
	databaseURL: import.meta.env.PUBLIC_FIREBASE_DATABASE_URL || null,
	projectId: import.meta.env.PUBLIC_FIREBASE_PROJECT_ID || null,
	storageBucket: import.meta.env.PUBLIC_FIREBASE_STORAGE_BUCKET || null,
	messagingSenderId: import.meta.env.PUBLIC_FIREBASE_MESSAGING_SENDER_ID || null,
	appId: import.meta.env.PUBLIC_FIREBASE_APP_ID || null
};
---

<html lang="es">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
		<meta name="generator" content={Astro.generator} />
		<meta name="description" content="Track your ice cream flavors easily - D√≥nde Est√° Mi Helado?" />
		<title>D√≥nde Est√° Mi Helado?</title>
		
		<!-- PWA Manifest -->
		<link rel="manifest" href="/manifest.json" />
		
		<!-- PWA Meta Tags -->
		<meta name="theme-color" content="#3B82F6" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="default" />
		<meta name="apple-mobile-web-app-title" content="Ice Cream Tracker" />
		
		<!-- iOS Icons -->
		<link rel="apple-touch-icon" sizes="72x72" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="96x96" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="128x128" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="144x144" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="152x152" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="192x192" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="384x384" href="/icons/app-icon.svg" />
		<link rel="apple-touch-icon" sizes="512x512" href="/icons/app-icon.svg" />
		
		<!-- Microsoft Tiles -->
		<meta name="msapplication-TileColor" content="#3B82F6" />
		<meta name="msapplication-TileImage" content="/icons/app-icon.svg" />
		
		<!-- Safe area CSS variables -->
		<style>
			:root {
				--safe-area-inset-top: env(safe-area-inset-top);
				--safe-area-inset-right: env(safe-area-inset-right);
				--safe-area-inset-bottom: env(safe-area-inset-bottom);
				--safe-area-inset-left: env(safe-area-inset-left);
			}
		</style>
	</head>
	<body class="bg-gradient-to-br from-blue-50 via-indigo-50 to-pink-50 min-h-screen transition-all duration-300 select-none overscroll-none">
		<!-- Main container with enhanced mobile-first design -->
		<div class="container mx-auto px-3 sm:px-4 py-6 sm:py-8 max-w-md">
			<!-- App header with improved animations -->
			<header class="text-center mb-10 animate-fade-in">
				<h1 class="text-4xl font-bold text-gray-800 mb-3 tracking-tight">
					üç¶ D√≥nde Est√° Mi Helado?
				</h1>
				<p class="text-gray-600 text-base leading-relaxed">
					No te olvides de tus sabores favoritos
				</p>
				<div class="w-16 h-1 bg-gradient-to-r from-pink-300 to-blue-300 rounded-full mx-auto mt-4"></div>
			</header>

			<!-- Main content area with enhanced design -->
			<main class="animate-slide-up">
				<div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-white/50 p-4 sm:p-6 md:p-8">
					<!-- Enhanced instructions -->
					<div class="mb-6 sm:mb-8 text-center">
						<p class="text-gray-700 text-base leading-relaxed">
							Escribe el sabor de cada helado en el campo correspondiente
						</p>
					</div>

					<!-- Enhanced ice cream containers grid -->
					<div class="space-y-3 sm:space-y-4 md:space-y-5">
						<!-- Container A - Grey with Letter A -->
						<IceCreamContainer 
							containerId="A"
							containerType="letter"
							letter="A"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container B - Grey with Letter B -->
						<IceCreamContainer 
							containerId="B"
							containerType="letter"
							letter="B"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container C - Grey with Letter C -->
						<IceCreamContainer 
							containerId="C"
							containerType="letter"
							letter="C"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container 4 - Plain Green -->
						<IceCreamContainer 
							containerId="4"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-green-50 to-emerald-50"
							borderColor="border-green-200"
							hoverBorderColor="hover:border-green-300"
							visualBgGradient="bg-gradient-to-br from-green-200 to-green-300"
							lidBgGradient="bg-gradient-to-br from-green-500 to-emerald-600"
							inputBorderColor="border-green-200"
							inputFocusRing="focus:ring-green-400"
						/>

						<!-- Container 5 - Plain Turquoise -->
						<IceCreamContainer 
							containerId="5"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-cyan-50 to-teal-50"
							borderColor="border-cyan-200"
							hoverBorderColor="hover:border-cyan-300"
							visualBgGradient="bg-gradient-to-br from-cyan-200 to-cyan-300"
							lidBgGradient="bg-gradient-to-br from-cyan-500 to-teal-600"
							inputBorderColor="border-cyan-200"
							inputFocusRing="focus:ring-cyan-400"
						/>

						<!-- Container 6 - Plain Pink -->
						<IceCreamContainer 
							containerId="6"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-pink-50 to-rose-50"
							borderColor="border-pink-200"
							hoverBorderColor="hover:border-pink-300"
							visualBgGradient="bg-gradient-to-br from-pink-200 to-pink-300"
							lidBgGradient="bg-gradient-to-br from-pink-500 to-rose-600"
							inputBorderColor="border-pink-200"
							inputFocusRing="focus:ring-pink-400"
						/>

						<!-- Container 7 - Plain Light Grey -->
						<IceCreamContainer 
							containerId="7"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-gray-50 to-slate-50"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-200 to-gray-300"
							lidBgGradient="bg-gradient-to-br from-gray-300 to-slate-400"
							inputBorderColor="border-gray-200"
							inputFocusRing="focus:ring-gray-400"
						/>
					</div>

					<!-- Enhanced status message with share functionality -->
					<div class="mt-6 sm:mt-8 text-center space-y-3 sm:space-y-4">
						<p id="save-status" class="text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300">
							<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
							</svg>
							Los cambios se guardar√°n autom√°ticamente
						</p>
						
						<!-- Share button -->
						<button 
							id="share-btn"
							class="hidden px-6 py-2 bg-gradient-to-r from-pink-500 to-purple-500 text-white rounded-lg hover:from-pink-600 hover:to-purple-600 transition-all duration-300 transform hover:scale-105 shadow-lg hover:shadow-xl"
						>
							<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
								<path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"></path>
							</svg>
							Compartir Sabores
						</button>
					</div>
				</div>
			</main>
		</div>

		<!-- Elegant version footer -->
		<footer class="container mx-auto px-3 sm:px-4 py-4 max-w-md">
			<div class="bg-white/40 backdrop-blur-sm rounded-xl border border-white/30 p-3 text-center shadow-sm">
				<div class="flex flex-col sm:flex-row items-center justify-center gap-2 text-xs text-gray-600">
					<!-- Git commit info -->
					<div class="flex items-center gap-2">
						<svg class="w-3 h-3 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265L11.764 7h4.236a1 1 0 01.949 1.316l-2 6A1 1 0 0114 15h-3.236l.949 2.684a1 1 0 01-1.898.632L8.236 15H4a1 1 0 01-.949-1.316l2-6A1 1 0 016 7h3.236l-.949-2.684a1 1 0 011.898-.632L12.316 3.051z" clip-rule="evenodd"></path>
						</svg>
						<span class="font-mono">#{gitInfo.hash}</span>
						<span class="hidden sm:inline text-gray-400">‚Ä¢</span>
					</div>
					
					<!-- Commit message (truncated on mobile) -->
					<div class="text-center sm:text-left">
						<span class="block sm:inline max-w-40 sm:max-w-none truncate" title={gitInfo.message}>
							{gitInfo.message.length > 30 ? gitInfo.message.substring(0, 30) + '...' : gitInfo.message}
						</span>
					</div>
					
					<!-- Build timestamp -->
					<div class="flex items-center gap-1 text-gray-500">
						<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
						</svg>
						<time class="font-mono text-xs" datetime={buildTime} title={`Built: ${new Date(buildTime).toLocaleString()}`}>
							{new Date(buildTime).toLocaleDateString('es-ES', { 
								month: 'short', 
								day: 'numeric', 
								hour: '2-digit', 
								minute: '2-digit'
							})}
						</time>
					</div>
				</div>
				
				<!-- Branch indicator (only show if not main) -->
				{gitInfo.branch !== 'main' && (
					<div class="mt-2 pt-2 border-t border-gray-200/50">
						<span class="inline-flex items-center gap-1 px-2 py-1 text-xs font-medium text-amber-800 bg-amber-100/80 rounded-full">
							<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M6 6V5a3 3 0 013-3h2a3 3 0 013 3v1h2a2 2 0 012 2v3.57A22.952 22.952 0 0110 13a22.95 22.95 0 01-8-1.43V8a2 2 0 012-2h2zM2.93 17.5c-.84.76-2.13.75-2.93.04V15.8c.55.34 1.23.5 1.93.5.7 0 1.38-.16 1.93-.5v1.74c0 .15-.06.3-.17.41l-.76.75z" clip-rule="evenodd"></path>
							</svg>
							branch: {gitInfo.branch}
						</span>
					</div>
				)}
			</div>
		</footer>

		<!-- Enhanced client-side JavaScript with Firebase real-time sync (Inlined) -->
		<script type="module" define:vars={{ firebaseEnvVars }}>
			// Firebase imports (using CDN to avoid build issues)
			import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
			import { getDatabase, ref, set, get, onValue, off } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js';

			// ========================================
			// FIREBASE CONFIGURATION & INITIALIZATION  
			// ========================================
			
			// Firebase configuration from server-side environment variables
			// Using Astro's define:vars to safely pass server variables to client
			const firebaseConfig = {
				apiKey: firebaseEnvVars.apiKey,
				authDomain: firebaseEnvVars.authDomain,
				databaseURL: firebaseEnvVars.databaseURL,
				projectId: firebaseEnvVars.projectId,
				storageBucket: firebaseEnvVars.storageBucket,
				messagingSenderId: firebaseEnvVars.messagingSenderId,
				appId: firebaseEnvVars.appId
			};

			// Validate that all required environment variables are present
			const requiredConfigKeys = ['apiKey', 'authDomain', 'databaseURL', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
			const missingVars = requiredConfigKeys.filter(key => !firebaseConfig[key] || firebaseConfig[key] === null || firebaseConfig[key] === 'null');

			let database = null;
			let isFirebaseInitialized = false;

			if (missingVars.length > 0) {
				console.warn('‚ö†Ô∏è Missing Firebase environment variables:', missingVars);
				console.warn('üìù Firebase will be disabled. App will use localStorage only.');
				console.warn('üîß Please check your Netlify environment variables or local .env file');
			} else {
				try {
					// Initialize Firebase
					const app = initializeApp(firebaseConfig);
					database = getDatabase(app);
					isFirebaseInitialized = true;
					console.log('üî• Firebase initialized successfully');
				} catch (error) {
					console.error('‚ùå Firebase initialization failed:', error);
					console.log('üì¶ Falling back to localStorage only');
				}
			}

			// ========================================
			// SESSION MANAGEMENT FUNCTIONS
			// ========================================
			
			function generateSessionId() {
				// Ice cream themed adjectives
				const adjectives = [
					'creamy', 'frosty', 'sweet', 'chunky', 'smooth', 'swirled', 
					'dreamy', 'melty', 'chilly', 'fluffy', 'rich', 'silky',
					'frozen', 'cool', 'crispy', 'soft', 'thick', 'light',
					'minty', 'nutty', 'fruity', 'cocoa', 'vanilla', 'strawberry'
				];
				
				// Ice cream themed nouns
				const nouns = [
					'sundae', 'scoop', 'cone', 'waffle', 'cherry', 'sprinkles',
					'banana', 'chocolate', 'caramel', 'fudge', 'cookie', 'brownie',
					'parfait', 'float', 'shake', 'swirl', 'sandwich', 'bar',
					'gelato', 'sorbet', 'popsicle', 'cream', 'split', 'topping'
				];
				
				// Pick random adjective and noun
				const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
				const noun = nouns[Math.floor(Math.random() * nouns.length)];
				
				// Add a small number for uniqueness
				const uniqueNumber = Math.floor(Math.random() * 999) + 1;
				
				const sessionId = `${adjective}-${noun}-${uniqueNumber}`;
				console.log(`üç¶ Generated fun session ID: ${sessionId}`);
				return sessionId;
			}

			function isValidSessionId(sessionId) {
				if (!sessionId || typeof sessionId !== 'string') {
					return false;
				}
				
				// Ice cream themed format: adjective-noun-number (e.g., 'creamy-sundae-42')
				const sessionRegex = /^[a-z]+-[a-z]+-[0-9]{1,3}$/;
				return sessionRegex.test(sessionId);
			}

			function getCurrentSessionId() {
				const urlParams = new URLSearchParams(window.location.search);
				const sessionId = urlParams.get('session');
				return (sessionId && isValidSessionId(sessionId)) ? sessionId : null;
			}

			function updateUrlWithSession(sessionId) {
				if (!isValidSessionId(sessionId)) {
					console.error('Invalid session ID provided:', sessionId);
					return;
				}
				const newUrl = `${window.location.pathname}?session=${sessionId}`;
				window.history.pushState({ sessionId }, '', newUrl);
				console.log(`üîó Updated URL with session: ${sessionId}`);
			}

			function clearSessionFromUrl() {
				window.history.pushState({}, document.title, window.location.pathname);
				console.log('üßπ Cleared session from URL - switched to local mode');
			}

			function generateShareableUrl(sessionId) {
				if (!isValidSessionId(sessionId)) {
					throw new Error('Invalid session ID provided');
				}
				return `${window.location.origin}${window.location.pathname}?session=${sessionId}`;
			}

			function getOrCreateSessionId() {
				const urlSessionId = getCurrentSessionId();
				if (urlSessionId) {
					console.log(`üì± Using existing session from URL: ${urlSessionId}`);
					return urlSessionId;
				}
				
				const newSessionId = generateSessionId();
				console.log(`üÜï Generated new session ID: ${newSessionId}`);
				updateUrlWithSession(newSessionId);
				return newSessionId;
			}

			// ========================================
			// FIREBASE DATA MANAGEMENT FUNCTIONS
			// ========================================
			
			function getSessionRef(sessionId, dataType = '') {
				const basePath = `sessions/${sessionId}`;
				return dataType ? ref(database, `${basePath}/${dataType}`) : ref(database, basePath);
			}

			async function saveFlavorsToFirebase(sessionId, flavors) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const flavorsRef = getSessionRef(sessionId, 'flavors');
					await set(flavorsRef, flavors);
					
					const metadataRef = getSessionRef(sessionId, 'metadata');
					await set(metadataRef, {
						lastUpdated: Date.now(),
						version: '1.0'
					});
					
					console.log(`‚úÖ Flavors saved to Firebase session: ${sessionId}`);
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					return true;
				} catch (error) {
					console.error('‚ùå Error saving flavors to Firebase:', error);
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					throw error;
				}
			}

			async function saveFillLevelsToFirebase(sessionId, fillLevels) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
					await set(fillLevelsRef, fillLevels);
					console.log(`‚úÖ Fill levels saved to Firebase session: ${sessionId}`);
					localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
					return true;
				} catch (error) {
					console.error('‚ùå Error saving fill levels to Firebase:', error);
					localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
					throw error;
				}
			}

			async function loadFlavorsFromFirebase(sessionId) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const flavorsRef = getSessionRef(sessionId, 'flavors');
					const snapshot = await get(flavorsRef);
					
					if (snapshot.exists()) {
						const flavors = snapshot.val();
						console.log(`üì• Flavors loaded from Firebase session: ${sessionId}`);
						localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
						return flavors;
					} else {
						console.log(`üì≠ No flavors found in Firebase session: ${sessionId}`);
						return {};
					}
				} catch (error) {
					console.error('‚ùå Error loading flavors from Firebase:', error);
					
					try {
						const savedFlavors = localStorage.getItem(STORAGE_KEY);
						if (savedFlavors) {
							console.log('üì¶ Using localStorage fallback for flavors');
							return JSON.parse(savedFlavors);
						}
					} catch (localError) {
						console.error('‚ùå Error loading from localStorage:', localError);
					}
					
					return {};
				}
			}

			async function loadFillLevelsFromFirebase(sessionId) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
					const snapshot = await get(fillLevelsRef);
					
					if (snapshot.exists()) {
						const fillLevels = snapshot.val();
						console.log(`üì• Fill levels loaded from Firebase session: ${sessionId}`);
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
						return fillLevels;
					} else {
						console.log(`üì≠ No fill levels found in Firebase session: ${sessionId}`);
						return {};
					}
				} catch (error) {
					console.error('‚ùå Error loading fill levels from Firebase:', error);
					
					try {
						const savedFillLevels = localStorage.getItem(FILL_LEVELS_KEY);
						if (savedFillLevels) {
							console.log('üì¶ Using localStorage fallback for fill levels');
							return JSON.parse(savedFillLevels);
						}
					} catch (localError) {
						console.error('‚ùå Error loading from localStorage:', localError);
					}
					
					return {};
				}
			}

			function setupRealtimeListeners(sessionId, onFlavorsChange, onFillLevelsChange) {
				if (!isFirebaseInitialized) {
					console.log('‚ö†Ô∏è Firebase not available - real-time sync disabled');
					return () => {}; // Return empty cleanup function
				}
				
				const flavorsRef = getSessionRef(sessionId, 'flavors');
				const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
				
				const flavorsUnsubscribe = onValue(flavorsRef, (snapshot) => {
					if (snapshot.exists()) {
						const flavors = snapshot.val();
						console.log(`üîÑ Real-time flavors update received for session: ${sessionId}`);
						localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
						if (onFlavorsChange) {
							onFlavorsChange(flavors);
						}
					}
				}, (error) => {
					console.error('‚ùå Error in flavors listener:', error);
				});
				
				const fillLevelsUnsubscribe = onValue(fillLevelsRef, (snapshot) => {
					if (snapshot.exists()) {
						const fillLevels = snapshot.val();
						console.log(`üîÑ Real-time fill levels update received for session: ${sessionId}`);
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
						if (onFillLevelsChange) {
							onFillLevelsChange(fillLevels);
						}
					}
				}, (error) => {
					console.error('‚ùå Error in fill levels listener:', error);
				});
				
				console.log(`üëÇ Real-time listeners set up for session: ${sessionId}`);
				
				return () => {
					console.log(`üëã Cleaning up listeners for session: ${sessionId}`);
					flavorsUnsubscribe();
					fillLevelsUnsubscribe();
				};
			}

			async function isFirebaseAvailable() {
				if (!isFirebaseInitialized) {
					console.log('üîå Firebase not initialized');
					return false;
				}
				
				try {
					// Test Firebase connectivity by trying a simple read
					const testRef = ref(database, '.info/serverTimeOffset');
					const snapshot = await get(testRef);
					console.log('üî• Firebase connectivity test passed');
					return true;
				} catch (error) {
					console.log('üîå Firebase connectivity test failed:', error.message);
					// Even if connectivity test fails, Firebase might still work
					// Let's return true if Firebase is initialized properly
					return isFirebaseInitialized;
				}
			}

			// Global session and state management
			let currentSessionId = null;
			let firebaseListenersCleanup = null;
			let isOnline = true;
			
			// Legacy storage keys for localStorage fallback
			const STORAGE_KEY = 'donde-esta-mi-helado-flavors';
			const FILL_LEVELS_KEY = 'donde-esta-mi-helado-fill-levels';

			// Creamy ice cream colors for realistic variety
			const ICE_CREAM_COLORS = [
				'from-amber-100 to-yellow-100',     // Vanilla cream
				'from-pink-100 to-rose-200',       // Strawberry
				'from-orange-100 to-amber-200',    // Peach
				'from-green-100 to-emerald-200',   // Mint chip
				'from-purple-100 to-violet-200',   // Lavender
				'from-yellow-100 to-amber-100',    // Banana
				'from-orange-200 to-yellow-200',   // Mango
				'from-pink-200 to-red-200',        // Cherry
				'from-green-200 to-lime-200',      // Pistachio
				'from-blue-100 to-cyan-200',       // Bubblegum
				'from-gray-100 to-slate-200',      // Cookies & cream
				'from-amber-200 to-orange-200',    // Caramel
				'from-indigo-100 to-blue-200',     // Blueberry
				'from-lime-100 to-green-200',      // Lime
				'from-rose-100 to-pink-200'        // Cotton candy
			];

			// Function to get random ice cream color
			function getRandomIceCreamColor() {
				return ICE_CREAM_COLORS[Math.floor(Math.random() * ICE_CREAM_COLORS.length)];
			}

			// Fill level states
			const FILL_LEVELS = {
				EMPTY: 0,
				HALF: 35,
				FULL: 80
			};

			// Global state for fill levels
			let containerFillLevels = {};

			// Initialize session and setup Firebase real-time sync
			async function initializeSession() {
				try {
					// Check if Firebase is available
					isOnline = await isFirebaseAvailable();
					console.log(`üîå Firebase status: ${isOnline ? 'online' : 'offline'}`);
					
					// Get or create session ID
					currentSessionId = getOrCreateSessionId();
					console.log(`üéØ Current session: ${currentSessionId}`);
					
					// Load initial data from Firebase (or localStorage if offline)
					await loadInitialData();
					
					// Set up real-time listeners if online
					if (isOnline && currentSessionId) {
						setupFirebaseListeners();
					}
					
					// Update UI to reflect session status
					updateSessionUI();
					
				} catch (error) {
					console.error('‚ùå Error initializing session:', error);
					// Fallback to localStorage mode
					await loadLocalStorageData();
				}
			}
			
			// Load initial data from Firebase or localStorage
			async function loadInitialData() {
				if (!currentSessionId) {
					await loadLocalStorageData();
					return;
				}
				
				try {
					// Load flavors and fill levels from Firebase
					const [flavors, fillLevels] = await Promise.all([
						loadFlavorsFromFirebase(currentSessionId),
						loadFillLevelsFromFirebase(currentSessionId)
					]);
					
					// Apply loaded data to UI
					applyFlavorsToUI(flavors);
					containerFillLevels = fillLevels || {};
					
					// Update visual states
					setTimeout(() => updateContainerVisuals(), 100);
					
					console.log('‚úÖ Initial data loaded from Firebase');
					
				} catch (error) {
					console.error('‚ùå Error loading from Firebase:', error);
					// Fallback to localStorage
					await loadLocalStorageData();
				}
			}
			
			// Fallback function to load from localStorage
			async function loadLocalStorageData() {
				try {
					console.log('üì¶ Loading from localStorage...');
					console.log('Storage keys:', {STORAGE_KEY, FILL_LEVELS_KEY});
					
					// Load flavors from localStorage
					const savedFlavors = localStorage.getItem(STORAGE_KEY);
					console.log('Saved flavors:', savedFlavors);
					
					if (savedFlavors) {
						const flavors = JSON.parse(savedFlavors);
						console.log('Parsed flavors:', flavors);
						applyFlavorsToUI(flavors);
					} else {
						console.log('No saved flavors found in localStorage');
					}
					
					// Load fill levels from localStorage
					const savedFillLevels = localStorage.getItem(FILL_LEVELS_KEY);
					console.log('Saved fill levels:', savedFillLevels);
					
					if (savedFillLevels) {
						containerFillLevels = JSON.parse(savedFillLevels);
						console.log('Parsed fill levels:', containerFillLevels);
					} else {
						console.log('No saved fill levels found in localStorage');
					}
					
					// Update visual states
					setTimeout(() => updateContainerVisuals(), 100);
					
					console.log('‚úÖ Data loaded from localStorage successfully');
					
				} catch (error) {
					console.error('‚ùå Error loading from localStorage:', error);
				}
			}
			
			// Apply flavors data to UI inputs
			function applyFlavorsToUI(flavors) {
				Object.keys(flavors).forEach(containerId => {
					const input = document.getElementById(`flavor-${containerId}`);
					if (input && flavors[containerId]) {
						input.value = flavors[containerId];
						// Add animation for loaded flavors
						input.classList.add('animate-pulse');
						setTimeout(() => input.classList.remove('animate-pulse'), 300);
					}
				});
			}

			// Setup Firebase real-time listeners for session data changes
			function setupFirebaseListeners() {
				if (!currentSessionId || firebaseListenersCleanup) {
					return; // Already set up or no session
				}
				
				console.log(`üëÇ Setting up Firebase listeners for session: ${currentSessionId}`);
				
				// Set up real-time listeners with callbacks
				firebaseListenersCleanup = setupRealtimeListeners(
					currentSessionId,
					// On flavors change callback
					(flavors) => {
						console.log('üîÑ Firebase flavors update received');
						applyFlavorsToUI(flavors);
						updateContainerVisuals();
						updateShareButton();
						updateEatButtons();
						showSyncStatus('synced');
					},
					// On fill levels change callback
					(fillLevels) => {
						console.log('üîÑ Firebase fill levels update received');
						containerFillLevels = fillLevels || {};
						updateContainerVisuals();
						showSyncStatus('synced');
					}
				);
			}
			
			// Enhanced function to save fill levels to Firebase and localStorage
			async function saveFillLevels() {
				try {
					// Save to Firebase if online and session exists
					if (isOnline && currentSessionId) {
						try {
							await saveFillLevelsToFirebase(currentSessionId, containerFillLevels);
							showSyncStatus('synced');
						} catch (error) {
							console.error('‚ùå Error saving fill levels to Firebase:', error);
							showSyncStatus('error');
							// Fallback to localStorage
							localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(containerFillLevels));
						}
					} else {
						// Save to localStorage only
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(containerFillLevels));
						showSyncStatus('offline');
					}
				} catch (error) {
					console.error('‚ùå Error saving fill levels:', error);
					showSyncStatus('error');
				}
			}

			// Enhanced function to save flavors to Firebase and localStorage  
			async function saveFlavors() {
				console.log('üöÄ saveFlavors() function called');
				try {
					const flavors = {};
					const inputs = document.querySelectorAll('.flavor-input');
					console.log(`üìã Found ${inputs.length} flavor inputs to process`);
					
					inputs.forEach((input, index) => {
						const containerId = input.dataset.container;
						const value = input.value.trim();
						console.log(`Input ${index}: container=${containerId}, value="${value}"`);
						if (containerId && value) {
							flavors[containerId] = value;
						}
					});
					
					console.log('üíæ Final flavors object to save:', flavors);
					console.log('üî• Firebase status:', {isOnline, currentSessionId, isFirebaseInitialized});
					
					// Always save to localStorage as backup
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					console.log('‚úÖ Flavors saved to localStorage');
					
					// Also try to save to Firebase if online and session exists
					if (isOnline && isFirebaseInitialized && currentSessionId) {
						try {
							console.log('üîÑ Attempting Firebase save...');
							await saveFlavorsToFirebase(currentSessionId, flavors);
							console.log('‚úÖ Flavors saved to Firebase');
							showSyncStatus('synced');
						} catch (error) {
							console.error('‚ùå Error saving to Firebase:', error);
							console.error('Firebase error details:', error.message);
							showSyncStatus('error');
						}
					} else {
						console.log('üì¶ Firebase not available - using localStorage only');
						showSyncStatus('offline');
					}
					
					// Enhanced save confirmation with smooth animation
					const status = document.getElementById('save-status');
					if (status) {
						status.innerHTML = `
							<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
							</svg>
							Guardado autom√°ticamente
						`;
						status.className = 'text-sm text-green-600 flex items-center justify-center gap-2 transition-all duration-300 transform scale-105';
						
						// Reset status message with smooth transition
						setTimeout(() => {
							status.innerHTML = `
								<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
									<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
								</svg>
								Los cambios se guardar√°n autom√°ticamente
							`;
							status.className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
						}, 2500);
					}
					
					console.log('‚úÖ Flavors saved to localStorage');
				} catch (error) {
					console.error('‚ùå Error saving flavors:', error);
					
					// Enhanced error message
					const status = document.getElementById('save-status');
					if (status) {
						status.innerHTML = `
							<svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
							</svg>
							Error al guardar
						`;
						status.className = 'text-sm text-red-600 flex items-center justify-center gap-2 transition-all duration-300';
						
						setTimeout(() => {
							status.innerHTML = `
								<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
									<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
								</svg>
								Los cambios se guardar√°n autom√°ticamente
							`;
							status.className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
						}, 3000);
					}
				}
			}

			// Debounce function to avoid too frequent saves
			function debounce(func, wait) {
				let timeout;
				return function executedFunction(...args) {
					console.log(`‚è∞ Debounce function called, will execute in ${wait}ms`);
					const later = () => {
						clearTimeout(timeout);
						console.log(`‚ö° Debounce timeout completed, executing function`);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
				};
			}

			// Show sync status to the user
			function showSyncStatus(status) {
				const statusElement = document.getElementById('save-status');
				if (!statusElement) return;
				
				let icon, message, className;
				
				switch (status) {
					case 'synced':
						icon = `<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
						</svg>`;
						message = currentSessionId ? 'Sincronizado con otros dispositivos' : 'Guardado autom√°ticamente';
						className = 'text-sm text-green-600 flex items-center justify-center gap-2 transition-all duration-300 transform scale-105';
						break;
					case 'offline':
						icon = `<svg class="w-4 h-4 text-orange-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Guardado localmente (sin conexi√≥n)';
						className = 'text-sm text-orange-600 flex items-center justify-center gap-2 transition-all duration-300';
						break;
					case 'error':
						icon = `<svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Error al guardar - reintentando...';
						className = 'text-sm text-red-600 flex items-center justify-center gap-2 transition-all duration-300';
						break;
					default:
						icon = `<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
															<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Los cambios se sincronizar√°n autom√°ticamente';
						className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
				}
				
				statusElement.innerHTML = `${icon}${message}`;
				statusElement.className = className;
				
				// Reset to default after a delay
				if (status !== 'default') {
					setTimeout(() => showSyncStatus('default'), 3000);
				}
			}

			// Debounced save function (saves 300ms after user stops typing - faster feedback)
			const debouncedSave = debounce(saveFlavors, 300);

			// Function to copy session share URL to clipboard
			async function copyShareURL() {
				if (!currentSessionId) {
					alert('‚ö†Ô∏è Error: No hay sesi√≥n activa para compartir');
					return;
				}
				
				// Check if there's content to share
				const inputs = document.querySelectorAll('.flavor-input');
				let hasContent = false;
				inputs.forEach(input => {
					if (input.value.trim()) {
						hasContent = true;
					}
				});
				
				if (!hasContent) {
					alert('‚ö†Ô∏è Agrega algunos sabores antes de compartir');
					return;
				}
				
				try {
					const shareURL = generateShareableUrl(currentSessionId);
					await navigator.clipboard.writeText(shareURL);
					
					// Update button text temporarily
					const shareBtn = document.getElementById('share-btn');
					const originalText = shareBtn.innerHTML;
					shareBtn.innerHTML = `
						<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
						</svg>
						¬°Copiado!
					`;
					shareBtn.classList.add('from-green-500', 'to-green-600');
					shareBtn.classList.remove('from-pink-500', 'to-purple-500');
					
					setTimeout(() => {
						shareBtn.innerHTML = originalText;
						shareBtn.classList.remove('from-green-500', 'to-green-600');
						shareBtn.classList.add('from-pink-500', 'to-purple-500');
					}, 2000);
					
					console.log(`‚úÖ Session share URL copied: ${shareURL}`);
				} catch (error) {
					console.error('‚ùå Error copying to clipboard:', error);
					// Fallback: show URL in alert
					const shareURL = generateShareableUrl(currentSessionId);
					alert(`üìã Copia este enlace para compartir:\n\n${shareURL}`);
				}
			}
			
			// Update UI to reflect session status
			function updateSessionUI() {
				const shareBtn = document.getElementById('share-btn');
				if (shareBtn && currentSessionId) {
					// Update share button text to reflect session sharing
					shareBtn.innerHTML = `
						<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
							<path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"></path>
						</svg>
						Compartir Sesi√≥n
					`;
				}
				
				// Show session status if available
				console.log(`üì± Session UI updated - Session: ${currentSessionId || 'none'}, Online: ${isOnline}`);
			}

			// Function to update share button visibility
			function updateShareButton() {
				const shareBtn = document.getElementById('share-btn');
				const inputs = document.querySelectorAll('.flavor-input');
				let hasContent = false;
				
				inputs.forEach(input => {
					if (input.value.trim()) {
						hasContent = true;
					}
				});
				
				if (hasContent) {
					shareBtn.classList.remove('hidden');
				} else {
					shareBtn.classList.add('hidden');
				}
			}

			// Function to update container visual states
			function updateContainerVisuals() {
				const inputs = document.querySelectorAll('.flavor-input');
				inputs.forEach(input => {
					const containerId = input.dataset.container;
					const container = input.closest('.group');
					const iceCreamFill = container.querySelector('.ice-cream-fill');
					const emptyIndicator = container.querySelector('.empty-indicator');
					
					if (input.value.trim()) {
						// Show ice cream fill when there's a flavor
						if (iceCreamFill) {
							// Apply random creamy color if not already set
							if (!iceCreamFill.dataset.colorSet || iceCreamFill.dataset.colorSet === 'false') {
								const randomColor = getRandomIceCreamColor();
								iceCreamFill.className = `ice-cream-fill absolute bottom-0 left-0 right-0 bg-gradient-to-t ${randomColor} transition-all duration-500 rounded-b-xl cursor-pointer z-20`;
								iceCreamFill.dataset.colorSet = 'true';
								console.log(`üé® Applied color to ${containerId}:`, randomColor);
							}
							
							// Get current fill level (default to FULL for new flavors)
							if (!containerFillLevels[containerId]) {
								containerFillLevels[containerId] = FILL_LEVELS.FULL;
							}
							const fillLevel = containerFillLevels[containerId];
							iceCreamFill.style.height = `${fillLevel}%`;
							iceCreamFill.style.opacity = '0.8';
							console.log(`üìä Set fill level for ${containerId} to ${fillLevel}%`);
						}
						
						// Make the ENTIRE ice cream visual container clickable for better UX
						const iceCreamVisual = container.querySelector('.ice-cream-visual');
						if (iceCreamVisual) {
							iceCreamVisual.style.cursor = 'pointer';
							iceCreamVisual.onclick = (e) => {
								e.preventDefault();
								e.stopPropagation();
								console.log(`üñ±Ô∏è Clicked ice cream VISUAL CONTAINER for ${containerId}`);
								toggleFillLevel(containerId);
							};
							console.log(`‚úÖ Added click handler to ENTIRE visual container for ${containerId}`);
						}
						
						if (emptyIndicator) {
							emptyIndicator.style.opacity = '0';
						}
					} else {
						// Show empty state when no flavor
						if (iceCreamFill) {
							iceCreamFill.style.height = '0%';
							iceCreamFill.style.opacity = '0';
							// Reset color and fill level for next flavor
							iceCreamFill.dataset.colorSet = 'false';
							containerFillLevels[containerId] = FILL_LEVELS.EMPTY;
						}
						
						// Remove click handler from visual container
						const iceCreamVisual = container.querySelector('.ice-cream-visual');
						if (iceCreamVisual) {
							iceCreamVisual.style.cursor = '';
							iceCreamVisual.onclick = null;
						}
						
						if (emptyIndicator) {
							emptyIndicator.style.opacity = '1';
						}
					}
				});
			}

			// Function to toggle fill level between FULL and HALF
			function toggleFillLevel(containerId) {
				console.log(`üéØ toggleFillLevel called for ${containerId}`);
				const input = document.getElementById(`flavor-${containerId}`);
				console.log(`üìù Found input:`, input);
				console.log(`üìù Input value:`, input?.value);
				
				if (!input || !input.value.trim()) {
					console.log(`‚ùå No input or empty value for ${containerId}`);
					return; // Only work with containers that have flavors
				}
				
				// Toggle between FULL and HALF
				const currentLevel = containerFillLevels[containerId] || FILL_LEVELS.FULL;
				const newLevel = currentLevel === FILL_LEVELS.FULL ? FILL_LEVELS.HALF : FILL_LEVELS.FULL;
				containerFillLevels[containerId] = newLevel;
				console.log(`üîÑ Toggling from ${currentLevel}% to ${newLevel}%`);
				
				// Update visual immediately
				const container = input.closest('.group');
				const iceCreamFill = container.querySelector('.ice-cream-fill');
				console.log(`üé® Found ice cream fill:`, iceCreamFill);
				
				if (iceCreamFill) {
					iceCreamFill.style.height = `${newLevel}%`;
					console.log(`ü•É Toggled ${containerId} fill level to ${newLevel}%`);
				}
				
				// Save state
				saveFillLevels();
			}

			// Function to update eat button states
			function updateEatButtons() {
				const eatBtns = document.querySelectorAll('.eat-btn');
				eatBtns.forEach(btn => {
					const containerId = btn.dataset.container;
					const input = document.getElementById(`flavor-${containerId}`);
					
					if (input && input.value.trim()) {
						// Enable button when there's a flavor
						btn.disabled = false;
						btn.classList.remove('opacity-0');
						btn.classList.add('opacity-100');
					} else {
						// Disable button when no flavor
						btn.disabled = true;
						btn.classList.remove('opacity-100');
						btn.classList.add('opacity-0');
					}
				});
				
				// Update visual states too
				updateContainerVisuals();
			}

			// Function to eat ice cream with fun animation
			async function eatIceCream(containerId) {
				const input = document.getElementById(`flavor-${containerId}`);
				const container = input.closest('.group');
				const eatBtn = container.querySelector('.eat-btn');
				
				if (!input.value.trim()) return;
				
				// Disable button during animation
				eatBtn.disabled = true;
				eatBtn.classList.add('animate-pulse');
				
				try {
					// Phase 1: Show "eating" animation on button
					eatBtn.innerHTML = 'ü§§';
					await new Promise(resolve => setTimeout(resolve, 300));
					
					// Phase 2: Ice cream drain animation
					const iceCreamFill = container.querySelector('.ice-cream-fill');
					const emptyIndicator = container.querySelector('.empty-indicator');
					
					if (iceCreamFill) {
						// Ensure ice cream has a random color before draining animation
						if (!iceCreamFill.dataset.colorSet || iceCreamFill.dataset.colorSet === 'false') {
							const randomColor = getRandomIceCreamColor();
							iceCreamFill.className = `ice-cream-fill absolute bottom-0 left-0 right-0 bg-gradient-to-t ${randomColor} transition-all duration-500 rounded-b-xl cursor-pointer`;
							iceCreamFill.dataset.colorSet = 'true';
						}
						// Animate ice cream "draining" as it's being eaten (works from any fill level)
						iceCreamFill.style.height = '20%';
						iceCreamFill.style.opacity = '0.4';
						iceCreamFill.style.transition = 'all 0.8s ease-in';
					}
					
					container.classList.add('animate-bounce');
					const iceCreamVisual = container.querySelector('.flex-shrink-0:first-child');
					iceCreamVisual.style.transform = 'scale(0.95) rotate(2deg)';
					iceCreamVisual.style.transition = 'all 0.5s ease-out';
					
					await new Promise(resolve => setTimeout(resolve, 500));
					
					// Phase 3: Complete ice cream disappearance
					if (iceCreamFill) {
						iceCreamFill.style.height = '0%';
						iceCreamFill.style.opacity = '0';
						iceCreamFill.style.transition = 'all 0.4s ease-out';
					}
					if (emptyIndicator) {
						emptyIndicator.style.opacity = '1';
						emptyIndicator.style.transition = 'opacity 0.4s ease-in 0.2s';
					}
					
					// Phase 4: Input field clear with fade effect
					input.style.transform = 'scale(0.9)';
					input.style.opacity = '0.3';
					input.style.transition = 'all 0.3s ease-out';
					
					await new Promise(resolve => setTimeout(resolve, 300));
					
					// Phase 5: Clear the flavor and show "Yum!" feedback
					input.value = '';
					containerFillLevels[containerId] = FILL_LEVELS.EMPTY; // Reset fill level
					if (iceCreamFill) {
						iceCreamFill.onclick = null; // Remove click handler
						// Reset color for next flavor
						iceCreamFill.dataset.colorSet = 'false';
					}
					eatBtn.innerHTML = 'üòã';
					
					// Phase 6: Show success message
					const originalBg = container.className;
					container.classList.add('ring-4', 'ring-green-200', 'ring-opacity-75');
					
					// Show temporary "Yum!" message
					const yumMessage = document.createElement('div');
					yumMessage.className = 'absolute top-2 right-2 bg-green-500 text-white px-3 py-1 rounded-full text-sm font-bold animate-bounce';
					yumMessage.textContent = '¬°√ëam!';
					yumMessage.style.zIndex = '50';
					container.style.position = 'relative';
					container.appendChild(yumMessage);
					
					await new Promise(resolve => setTimeout(resolve, 1500));
					
					// Phase 7: Reset everything (but keep visual state empty since ice cream was eaten)
					container.classList.remove('animate-bounce', 'ring-4', 'ring-green-200', 'ring-opacity-75');
					iceCreamVisual.style.transform = '';
					input.style.transform = '';
					input.style.opacity = '';
					eatBtn.classList.remove('animate-pulse');
					
					// Remove yum message
					if (yumMessage) {
						yumMessage.remove();
					}
					
					// Save the updated state
					saveFlavors();
					saveFillLevels(); // Save updated fill levels
					updateShareButton();
					updateEatButtons();
					
					console.log(`üòã Ice cream ${containerId} eaten!`);
					
				} catch (error) {
					console.error('‚ùå Error eating ice cream:', error);
					// Reset on error
					eatBtn.innerHTML = 'üòã';
					eatBtn.classList.remove('animate-pulse');
					eatBtn.disabled = false;
				}
			}

			// Initialize the app when DOM is loaded
			document.addEventListener('DOMContentLoaded', function() {
				// Add loading animation to main content
				const main = document.querySelector('main');
				main.style.opacity = '0';
				main.style.transform = 'translateY(20px)';
				
				setTimeout(() => {
					main.style.transition = 'all 0.6s ease-out';
					main.style.opacity = '1';
					main.style.transform = 'translateY(0)';
				}, 100);
				
				// Initialize Firebase session and load data
				initializeSession();
				
				// Add enhanced event listeners to all flavor inputs
				const inputs = document.querySelectorAll('.flavor-input');
				console.log(`üéØ Setting up event listeners for ${inputs.length} flavor inputs`);
				
				inputs.forEach((input, index) => {
					console.log(`üìù Setting up listeners for input ${index}: ${input.id}`);
					
					// Save on input (typing) with faster response
					input.addEventListener('input', (e) => {
						console.log(`‚å®Ô∏è Input event triggered on ${e.target.id}: "${e.target.value}"`);
						debouncedSave();
						updateShareButton();
						updateEatButtons();
						updateContainerVisuals(); // Immediate visual update
					});
					
					// Save immediately on blur (when user leaves the field)  
					input.addEventListener('blur', (e) => {
						console.log(`üëÅÔ∏è Blur event triggered on ${e.target.id}: "${e.target.value}"`);
						saveFlavors();
						saveFillLevels(); // Also save fill levels
						updateShareButton();
						updateEatButtons();
						updateContainerVisuals(); // Ensure visual state is correct
					});
					
					// Add focus enhancement
					input.addEventListener('focus', function() {
						this.parentElement.parentElement.classList.add('ring-2', 'ring-blue-200', 'ring-opacity-50');
					});
					
					input.addEventListener('blur', function() {
						this.parentElement.parentElement.classList.remove('ring-2', 'ring-blue-200', 'ring-opacity-50');
					});
				});
				
				// Add eat button event listeners
				const eatBtns = document.querySelectorAll('.eat-btn');
				eatBtns.forEach(btn => {
					btn.addEventListener('click', () => {
						const containerId = btn.dataset.container;
						eatIceCream(containerId);
					});
				});
				
				// Add share button event listener
				const shareBtn = document.getElementById('share-btn');
				if (shareBtn) {
					shareBtn.addEventListener('click', copyShareURL);
				}
				
				// Initial button state updates
				updateShareButton();
				updateEatButtons();
				
				console.log('üç¶ D√≥nde Est√° Mi Helado? initialized with enhanced UX and sharing');
			
			// ========================================
			// PWA SERVICE WORKER REGISTRATION
			// ========================================
			
			// Register service worker for offline functionality
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', async () => {
					try {
						const registration = await navigator.serviceWorker.register('/sw.js');
						console.log('‚úÖ Service Worker registered successfully', registration);
						
						// Listen for service worker updates
						registration.addEventListener('updatefound', () => {
							const newWorker = registration.installing;
							newWorker.addEventListener('statechange', () => {
								if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
									console.log('üîÑ New version available - refresh to update');
									// Could show a user notification here
								}
							});
						});
						
					} catch (error) {
						console.error('‚ùå Service Worker registration failed:', error);
					}
				});
				
				// Listen for messages from service worker
				navigator.serviceWorker.addEventListener('message', (event) => {
					console.log('üì® Message from Service Worker:', event.data);
					
					if (event.data.type === 'SYNC_FIREBASE') {
						console.log('üîÑ Service Worker requesting Firebase sync');
						// Trigger Firebase sync when connection is restored
						if (currentSessionId && isFirebaseInitialized) {
							saveFlavors();
							saveFillLevels();
						}
					}
				});
			}
			
			// ========================================
			// PWA INSTALLATION PROMPT
			// ========================================
			
			let deferredPrompt;
			let installButton;
			
			// Create install button
			function createInstallButton() {
				installButton = document.createElement('button');
				installButton.innerHTML = `
					<svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
						<path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
					</svg>
					Instalar App
				`;
				installButton.className = 'hidden px-4 py-2 bg-gradient-to-r from-green-500 to-blue-500 text-white rounded-lg hover:from-green-600 hover:to-blue-600 transition-all duration-300 transform hover:scale-105 shadow-lg hover:shadow-xl text-sm font-medium flex items-center mx-auto mt-4';
				installButton.onclick = installApp;
				
				// Add to share button container
				const shareContainer = document.getElementById('share-btn').parentElement;
				shareContainer.appendChild(installButton);
			}
			
			// PWA install prompt handling
			window.addEventListener('beforeinstallprompt', (e) => {
				console.log('üì± PWA install prompt available');
				e.preventDefault();
				deferredPrompt = e;
				
				// Show install button
				if (!installButton) {
					createInstallButton();
				}
				installButton.classList.remove('hidden');
			});
			
			// Install app function
			async function installApp() {
				if (!deferredPrompt) {
					console.log('‚ùå No install prompt available');
					return;
				}
				
				// Show the install prompt
				deferredPrompt.prompt();
				
				// Wait for the user's response
				const { outcome } = await deferredPrompt.userChoice;
				console.log(`üë§ User response to install prompt: ${outcome}`);
				
				if (outcome === 'accepted') {
					console.log('‚úÖ User accepted the install prompt');
				} else {
					console.log('‚ùå User dismissed the install prompt');
				}
				
				// Hide the install button
				installButton.classList.add('hidden');
				deferredPrompt = null;
			}
			
			// Handle successful installation
			window.addEventListener('appinstalled', () => {
				console.log('üéâ PWA was installed successfully');
				if (installButton) {
					installButton.classList.add('hidden');
				}
				deferredPrompt = null;
				
				// Optional: Track installation event
				showSyncStatus('synced');
				setTimeout(() => {
					const status = document.getElementById('save-status');
					if (status) {
						status.innerHTML = `
							<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
							</svg>
							¬°App instalada correctamente! üì±
						`;
						status.className = 'text-sm text-green-600 flex items-center justify-center gap-2 transition-all duration-300';
					}
				}, 1000);
			});
			
			// ========================================
			// PHASE 8.4: NATIVE TOUCH GESTURES
			// ========================================
			
			// Touch gesture variables
			let touchStartY = 0;
			let touchStartX = 0;
			let isScrolling = false;
			let longPressTimer = null;
			let lastTap = 0;
			let pullToRefreshTriggered = false;
			
			// Pull-to-refresh functionality
			let pullDistance = 0;
			let isPulling = false;
			const PULL_THRESHOLD = 80;
			const MAX_PULL_DISTANCE = 120;
			
			// Create pull-to-refresh indicator
			function createPullToRefreshIndicator() {
				const indicator = document.createElement('div');
				indicator.id = 'pull-refresh-indicator';
				indicator.className = 'fixed top-0 left-0 right-0 bg-gradient-to-r from-blue-500 to-purple-500 text-white text-center py-3 transform -translate-y-full transition-transform duration-300 z-50';
				indicator.innerHTML = `
					<div class="flex items-center justify-center gap-2">
						<svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
						</svg>
						<span id="refresh-text">Desliza para actualizar</span>
					</div>
				`;
				document.body.appendChild(indicator);
				return indicator;
			}
			
			const refreshIndicator = createPullToRefreshIndicator();
			
			// Haptic feedback simulation
			function triggerHapticFeedback(type = 'light') {
				// Use Vibration API if available
				if ('vibrator' in navigator || 'vibrate' in navigator) {
					const patterns = {
						light: [10],
						medium: [20],
						heavy: [30],
						success: [10, 10, 10],
						error: [50, 30, 50]
					};
					navigator.vibrate(patterns[type] || patterns.light);
				}
				
				// Visual feedback as fallback
				document.body.classList.add('haptic-feedback');
				setTimeout(() => document.body.classList.remove('haptic-feedback'), 100);
			}
			
			// Pull-to-refresh touch handling
			document.addEventListener('touchstart', (e) => {
				touchStartY = e.touches[0].clientY;
				touchStartX = e.touches[0].clientX;
				isScrolling = false;
				pullToRefreshTriggered = false;
				
				// Check if we're at the top of the page for pull-to-refresh
				if (window.scrollY === 0) {
					isPulling = true;
				}
				
				// Long press detection
				longPressTimer = setTimeout(() => {
					if (!isScrolling) {
						handleLongPress(e);
					}
				}, 600);
			}, { passive: false });
			
			document.addEventListener('touchmove', (e) => {
				if (!touchStartY) return;
				
				const touchY = e.touches[0].clientY;
				const touchX = e.touches[0].clientX;
				const diffY = touchY - touchStartY;
				const diffX = touchX - touchStartX;
				
				// Determine if we're scrolling
				if (Math.abs(diffY) > 10 || Math.abs(diffX) > 10) {
					isScrolling = true;
					clearTimeout(longPressTimer);
				}
				
				// Pull-to-refresh logic
				if (isPulling && diffY > 0 && window.scrollY === 0) {
					e.preventDefault();
					pullDistance = Math.min(diffY * 0.5, MAX_PULL_DISTANCE);
					
					// Update indicator
					const progress = Math.min(pullDistance / PULL_THRESHOLD, 1);
					refreshIndicator.style.transform = `translateY(${pullDistance - 60}px)`;
					
					if (pullDistance >= PULL_THRESHOLD && !pullToRefreshTriggered) {
						triggerHapticFeedback('medium');
						document.getElementById('refresh-text').textContent = '¬°Suelta para actualizar!';
						pullToRefreshTriggered = true;
					} else if (pullDistance < PULL_THRESHOLD && pullToRefreshTriggered) {
						document.getElementById('refresh-text').textContent = 'Desliza para actualizar';
						pullToRefreshTriggered = false;
					}
				}
			}, { passive: false });
			
			document.addEventListener('touchend', (e) => {
				clearTimeout(longPressTimer);
				
				if (isPulling) {
					if (pullToRefreshTriggered && pullDistance >= PULL_THRESHOLD) {
						// Trigger refresh
						triggerHapticFeedback('success');
						refreshIndicator.style.transform = 'translateY(0)';
						document.getElementById('refresh-text').innerHTML = `
							<div class="flex items-center justify-center gap-2">
								<svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
								</svg>
								<span>Actualizando...</span>
							</div>
						`;
						
						// Perform refresh actions
						performPullToRefresh();
					} else {
						// Snap back
						refreshIndicator.style.transform = 'translateY(-100%)';
					}
					
					isPulling = false;
					pullDistance = 0;
				}
				
				// Handle double tap
				const now = Date.now();
				if (now - lastTap < 300) {
					handleDoubleTap(e);
				}
				lastTap = now;
				
				touchStartY = 0;
				touchStartX = 0;
			});
			
			// Pull-to-refresh action
			async function performPullToRefresh() {
				try {
					console.log('üîÑ Pull-to-refresh triggered');
					
					// Reload data from Firebase
					if (currentSessionId && isFirebaseInitialized) {
						await loadInitialData();
						console.log('‚úÖ Data refreshed from Firebase');
					} else {
						await loadLocalStorageData();
						console.log('‚úÖ Data refreshed from localStorage');
					}
					
					// Update UI
					updateContainerVisuals();
					showSyncStatus('synced');
					
					// Success feedback
					setTimeout(() => {
						refreshIndicator.style.transform = 'translateY(-100%)';
						document.getElementById('refresh-text').textContent = '¬°Actualizado! üéâ';
						setTimeout(() => {
							document.getElementById('refresh-text').textContent = 'Desliza para actualizar';
						}, 1000);
					}, 800);
					
				} catch (error) {
					console.error('‚ùå Pull-to-refresh failed:', error);
					triggerHapticFeedback('error');
					refreshIndicator.style.transform = 'translateY(-100%)';
					document.getElementById('refresh-text').textContent = 'Error al actualizar';
					setTimeout(() => {
						document.getElementById('refresh-text').textContent = 'Desliza para actualizar';
					}, 2000);
				}
			}
			
			// Long press handler
			function handleLongPress(e) {
				console.log('üëÜ Long press detected');
				triggerHapticFeedback('medium');
				
				const target = e.target.closest('.flavor-input, .ice-cream-visual');
				if (target) {
					if (target.classList.contains('flavor-input')) {
						// Show context menu for input
						showInputContextMenu(target, e.touches[0]);
					} else if (target.classList.contains('ice-cream-visual')) {
						// Show context menu for ice cream container
						showContainerContextMenu(target, e.touches[0]);
					}
				}
			}
			
			// Double tap handler
			function handleDoubleTap(e) {
				console.log('üëÜüëÜ Double tap detected');
				triggerHapticFeedback('light');
				
				const target = e.target.closest('.ice-cream-visual');
				if (target) {
					// Double tap to eat ice cream
					const containerId = target.dataset.container;
					if (containerId) {
						eatIceCream(containerId);
					}
				}
			}
			
			// Context menu for input fields
			function showInputContextMenu(input, touch) {
				const menu = document.createElement('div');
				menu.className = 'fixed bg-white rounded-xl shadow-2xl border border-gray-200 p-2 z-50 animate-fade-in';
				menu.style.left = `${Math.min(touch.clientX, window.innerWidth - 200)}px`;
				menu.style.top = `${Math.max(touch.clientY - 100, 20)}px`;
				
				const actions = [
					{ text: 'üìã Pegar', action: () => pasteToInput(input) },
					{ text: 'üóëÔ∏è Limpiar', action: () => clearInput(input) },
					{ text: 'üç¶ Sabor aleatorio', action: () => setRandomFlavor(input) }
				];
				
				actions.forEach(action => {
					const button = document.createElement('button');
					button.className = 'block w-full text-left px-4 py-2 hover:bg-gray-50 rounded-lg transition-colors';
					button.textContent = action.text;
					button.onclick = () => {
						action.action();
						document.body.removeChild(menu);
						triggerHapticFeedback('light');
					};
					menu.appendChild(button);
				});
				
				document.body.appendChild(menu);
				
				// Remove menu after 3 seconds or on touch outside
				setTimeout(() => {
					if (document.body.contains(menu)) {
						document.body.removeChild(menu);
					}
				}, 3000);
				
				document.addEventListener('touchstart', function removeMenu(e) {
					if (!menu.contains(e.target)) {
						if (document.body.contains(menu)) {
							document.body.removeChild(menu);
						}
						document.removeEventListener('touchstart', removeMenu);
					}
				});
			}
			
			// Context menu for ice cream containers
			function showContainerContextMenu(container, touch) {
				const menu = document.createElement('div');
				menu.className = 'fixed bg-white rounded-xl shadow-2xl border border-gray-200 p-2 z-50 animate-fade-in';
				menu.style.left = `${Math.min(touch.clientX, window.innerWidth - 200)}px`;
				menu.style.top = `${Math.max(touch.clientY - 150, 20)}px`;
				
				const containerId = container.dataset.container;
				const currentLevel = containerFillLevels[containerId] || 80;
				
				const actions = [
					{ text: 'üç¶ Llenar (80%)', action: () => setFillLevel(containerId, 80) },
					{ text: 'ü•Ñ Medio (50%)', action: () => setFillLevel(containerId, 50) },
					{ text: 'üòã Poco (20%)', action: () => setFillLevel(containerId, 20) },
					{ text: 'üóëÔ∏è Vac√≠o (0%)', action: () => setFillLevel(containerId, 0) }
				];
				
				actions.forEach(action => {
					const button = document.createElement('button');
					button.className = 'block w-full text-left px-4 py-2 hover:bg-gray-50 rounded-lg transition-colors';
					button.textContent = action.text;
					button.onclick = () => {
						action.action();
						document.body.removeChild(menu);
						triggerHapticFeedback('light');
					};
					menu.appendChild(button);
				});
				
				document.body.appendChild(menu);
				
				// Remove menu after 3 seconds or on touch outside
				setTimeout(() => {
					if (document.body.contains(menu)) {
						document.body.removeChild(menu);
					}
				}, 3000);
				
				document.addEventListener('touchstart', function removeMenu(e) {
					if (!menu.contains(e.target)) {
						if (document.body.contains(menu)) {
							document.body.removeChild(menu);
						}
						document.removeEventListener('touchstart', removeMenu);
					}
				});
			}
			
			// Helper functions for context menu actions
			async function pasteToInput(input) {
				try {
					const text = await navigator.clipboard.readText();
					input.value = text;
					input.dispatchEvent(new Event('input', { bubbles: true }));
				} catch (error) {
					console.log('‚ùå Clipboard access denied');
				}
			}
			
			function clearInput(input) {
				input.value = '';
				input.dispatchEvent(new Event('input', { bubbles: true }));
			}
			
			function setRandomFlavor(input) {
				const flavors = [
					'Vainilla', 'Chocolate', 'Fresa', 'Menta', 'Cookies & Cream',
					'Dulce de Leche', 'Pistacho', 'Lim√≥n', 'Mango', 'Coco',
					'Caf√©', 'Caramelo', 'Frambuesa', 'Banana', 'Stracciatella'
				];
				const randomFlavor = flavors[Math.floor(Math.random() * flavors.length)];
				input.value = randomFlavor;
				input.dispatchEvent(new Event('input', { bubbles: true }));
			}
			
			function setFillLevel(containerId, level) {
				containerFillLevels[containerId] = level;
				updateContainerVisuals();
				saveFillLevels();
			}
			
			console.log('üëÜ Native touch gestures initialized');
			
			// ========================================
			// PHASE 8.5: PERFORMANCE OPTIMIZATION
			// ========================================
			
			// App shell loading optimization
			function initializeAppShell() {
				console.log('üöÄ Initializing app shell architecture');
				
				// Preload critical resources
				const criticalResources = [
					'/manifest.json',
					'/icons/app-icon.svg',
					'/sw.js'
				];
				
				criticalResources.forEach(resource => {
					const link = document.createElement('link');
					link.rel = 'prefetch';
					link.href = resource;
					document.head.appendChild(link);
				});
			}
			
			// Loading state management
			let isAppLoading = true;
			
			function showLoadingState() {
				const loadingOverlay = document.createElement('div');
				loadingOverlay.id = 'app-loading';
				loadingOverlay.className = 'fixed inset-0 bg-gradient-to-br from-blue-50 via-indigo-50 to-pink-50 flex items-center justify-center z-50';
				loadingOverlay.innerHTML = `
					<div class="text-center">
						<div class="relative mb-8">
							<!-- Animated ice cream loading icon -->
							<div class="w-20 h-20 mx-auto relative animate-pulse-gentle">
								<div class="absolute inset-0 bg-gradient-to-b from-pink-200 to-pink-300 rounded-full"></div>
								<div class="absolute top-2 left-2 right-2 bottom-6 bg-gradient-to-b from-yellow-100 to-yellow-200 rounded-full"></div>
								<div class="absolute top-4 left-4 right-4 bottom-12 bg-gradient-to-b from-green-100 to-green-200 rounded-full"></div>
								<div class="absolute top-1 left-1/2 transform -translate-x-1/2 w-3 h-3 bg-red-500 rounded-full"></div>
							</div>
						</div>
						<h2 class="text-2xl font-bold text-gray-800 mb-2">üç¶ D√≥nde Est√° Mi Helado?</h2>
						<p class="text-gray-600 animate-pulse">Preparando tu experiencia helada...</p>
					</div>
				`;
				document.body.appendChild(loadingOverlay);
			}
			
			function hideLoadingState() {
				const loadingOverlay = document.getElementById('app-loading');
				if (loadingOverlay) {
					loadingOverlay.style.opacity = '0';
					loadingOverlay.style.transform = 'scale(0.95)';
					loadingOverlay.style.transition = 'all 0.3s ease-out';
					setTimeout(() => {
						if (document.body.contains(loadingOverlay)) {
							document.body.removeChild(loadingOverlay);
						}
					}, 300);
				}
				isAppLoading = false;
			}
			
			// Performance monitoring
			function measurePerformance() {
				if ('performance' in window) {
					const navigation = performance.getEntriesByType('navigation')[0];
					const paintEntries = performance.getEntriesByType('paint');
					
					console.log('‚ö° Performance Metrics:');
					console.log(`- DOM Content Loaded: ${navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart}ms`);
					console.log(`- Total Load Time: ${navigation.loadEventEnd - navigation.loadEventStart}ms`);
					
					paintEntries.forEach(entry => {
						console.log(`- ${entry.name}: ${entry.startTime}ms`);
					});
					
					// Measure Time to Interactive
					setTimeout(() => {
						console.log(`- Time to Interactive: ${Date.now() - navigation.loadEventEnd}ms`);
					}, 100);
				}
			}
			
			// Image lazy loading optimization
			function optimizeImageLoading() {
				const images = document.querySelectorAll('img[data-src]');
				
				if ('IntersectionObserver' in window) {
					const imageObserver = new IntersectionObserver((entries) => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								const img = entry.target;
								img.src = img.dataset.src;
								img.classList.remove('lazy');
								imageObserver.unobserve(img);
							}
						});
					});
					
					images.forEach(img => imageObserver.observe(img));
				} else {
					// Fallback for older browsers
					images.forEach(img => {
						img.src = img.dataset.src;
						img.classList.remove('lazy');
					});
				}
			}
			
			// Memory optimization
			function optimizeMemoryUsage() {
				// Clean up unused event listeners on scroll
				let scrollTimeout;
				window.addEventListener('scroll', () => {
					clearTimeout(scrollTimeout);
					scrollTimeout = setTimeout(() => {
						// Trigger garbage collection if available
						if (window.gc && typeof window.gc === 'function') {
							window.gc();
						}
					}, 1000);
				}, { passive: true });
				
				// Clean up DOM nodes periodically
				setInterval(() => {
					// Remove any orphaned context menus
					const orphanedMenus = document.querySelectorAll('[class*="context-menu"]:not([style*="display: block"])');
					orphanedMenus.forEach(menu => {
						if (document.body.contains(menu)) {
							document.body.removeChild(menu);
						}
					});
				}, 30000); // Every 30 seconds
			}
			
			// Network optimization
			function optimizeNetworkRequests() {
				// Firebase connection pooling
				if (isFirebaseInitialized) {
					// Batch multiple Firebase operations
					let pendingWrites = [];
					let batchTimeout;
					
					const originalSaveFlavors = saveFlavors;
					saveFlavors = function() {
						pendingWrites.push('flavors');
						clearTimeout(batchTimeout);
						batchTimeout = setTimeout(() => {
							originalSaveFlavors();
							pendingWrites = [];
						}, 100); // Batch writes within 100ms
					};
				}
			}
			
			// Resource preloading for faster subsequent loads
			function preloadCriticalResources() {
				// Preload Firebase SDK if not already loaded
				if (!isFirebaseInitialized) {
					const script = document.createElement('link');
					script.rel = 'preload';
					script.as = 'script';
					script.href = 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
					document.head.appendChild(script);
				}
				
				// Preload Web Font if needed (although we're using system fonts)
				const link = document.createElement('link');
				link.rel = 'preconnect';
				link.href = 'https://fonts.googleapis.com';
				document.head.appendChild(link);
			}
			
			// Progressive enhancement loading
			function loadProgressiveEnhancements() {
				// Load non-critical features after initial render
				requestIdleCallback(() => {
					// Initialize analytics if available
					if (typeof gtag !== 'undefined') {
						gtag('config', 'GA_TRACKING_ID');
					}
					
					// Initialize additional PWA features
					if ('share' in navigator) {
						console.log('üì± Native sharing available');
					}
					
					if ('contacts' in navigator) {
						console.log('üìû Contacts API available');
					}
				});
			}
			
			// Initialize performance optimizations
			function initializePerformanceOptimizations() {
				showLoadingState();
				initializeAppShell();
				optimizeImageLoading();
				optimizeMemoryUsage();
				optimizeNetworkRequests();
				preloadCriticalResources();
				
				// Hide loading state after app is ready
				setTimeout(() => {
					hideLoadingState();
					measurePerformance();
					loadProgressiveEnhancements();
					console.log('‚ö° Performance optimizations initialized');
				}, 500);
			}
			
			initializePerformanceOptimizations();
			
			// ========================================
			// PHASE 8.6: DEVICE INTEGRATION
			// ========================================
			
			// Screen Wake Lock API
			let wakeLock = null;
			
			async function requestWakeLock() {
				try {
					if ('wakeLock' in navigator) {
						wakeLock = await navigator.wakeLock.request('screen');
						console.log('üîÜ Screen wake lock acquired');
						
						wakeLock.addEventListener('release', () => {
							console.log('üîÜ Screen wake lock released');
						});
					}
				} catch (error) {
					console.log('‚ùå Wake lock failed:', error);
				}
			}
			
			// Device orientation handling
			function handleOrientationChange() {
				const handleOrientation = () => {
					const orientation = screen.orientation?.type || 'unknown';
					console.log('üì± Orientation changed to:', orientation);
					
					// Trigger haptic feedback on orientation change
					triggerHapticFeedback('light');
					
					// Adjust UI for orientation
					if (orientation.includes('landscape')) {
						document.body.classList.add('landscape-mode');
						// Optionally adjust container layout for landscape
					} else {
						document.body.classList.remove('landscape-mode');
					}
				};
				
				if (screen.orientation) {
					screen.orientation.addEventListener('change', handleOrientation);
				} else {
					// Fallback for older browsers
					window.addEventListener('orientationchange', handleOrientation);
				}
				
				// Initial orientation check
				handleOrientation();
			}
			
			// Network status monitoring
			function monitorNetworkStatus() {
				function updateNetworkStatus() {
					const isOnlineNow = navigator.onLine;
					console.log(`üåê Network status: ${isOnlineNow ? 'online' : 'offline'}`);
					
					if (isOnlineNow !== isOnline) {
						isOnline = isOnlineNow;
						
						if (isOnline) {
							// Back online - trigger sync
							triggerHapticFeedback('success');
							showSyncStatus('synced');
							if (currentSessionId && isFirebaseInitialized) {
								saveFlavors();
								saveFillLevels();
							}
						} else {
							// Gone offline
							triggerHapticFeedback('error');
							showSyncStatus('offline');
						}
					}
				}
				
				window.addEventListener('online', updateNetworkStatus);
				window.addEventListener('offline', updateNetworkStatus);
				updateNetworkStatus(); // Initial check
			}
			
			// Battery status monitoring
			async function monitorBatteryStatus() {
				try {
					if ('getBattery' in navigator) {
						const battery = await navigator.getBattery();
						
						function updateBatteryInfo() {
							const level = Math.round(battery.level * 100);
							const charging = battery.charging;
							console.log(`üîã Battery: ${level}% ${charging ? '(charging)' : ''}`);
							
							// Show battery warning if low and not charging
							if (level < 20 && !charging) {
								console.log('‚ö†Ô∏è Low battery detected');
								// Could show a subtle notification
							}
						}
						
						battery.addEventListener('chargingchange', updateBatteryInfo);
						battery.addEventListener('levelchange', updateBatteryInfo);
						updateBatteryInfo(); // Initial check
					}
				} catch (error) {
					console.log('üîã Battery API not available');
				}
			}
			
			// Device memory monitoring
			function monitorDeviceMemory() {
				if ('memory' in performance) {
					const memory = performance.memory;
					console.log('üíæ Memory Usage:', {
						used: Math.round(memory.usedJSHeapSize / 1024 / 1024) + 'MB',
						total: Math.round(memory.totalJSHeapSize / 1024 / 1024) + 'MB',
						limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'
					});
					
					// Warning if memory usage is high
					const usagePercentage = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
					if (usagePercentage > 0.8) {
						console.log('‚ö†Ô∏è High memory usage detected');
						// Trigger cleanup
						optimizeMemoryUsage();
					}
				}
				
				if ('deviceMemory' in navigator) {
					console.log(`üíæ Device Memory: ${navigator.deviceMemory}GB`);
					
					// Adjust performance based on device memory
					if (navigator.deviceMemory < 2) {
						console.log('üì± Low-memory device detected - optimizing');
						// Reduce animation complexity, disable some features
						document.body.classList.add('low-memory-mode');
					}
				}
			}
			
			// Keyboard handling for mobile
			function handleMobileKeyboard() {
				const viewport = document.querySelector('meta[name=viewport]');
				
				function handleKeyboardShow() {
					console.log('‚å®Ô∏è Virtual keyboard shown');
					document.body.classList.add('keyboard-open');
					
					// Adjust viewport for keyboard
					viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no');
				}
				
				function handleKeyboardHide() {
					console.log('‚å®Ô∏è Virtual keyboard hidden');
					document.body.classList.remove('keyboard-open');
					
					// Restore viewport
					viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, viewport-fit=cover');
				}
				
				// iOS Safari keyboard detection
				if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
					let initialViewportHeight = window.visualViewport?.height || window.innerHeight;
					
					function checkKeyboard() {
						const currentHeight = window.visualViewport?.height || window.innerHeight;
						const heightDifference = initialViewportHeight - currentHeight;
						
						if (heightDifference > 150) { // Keyboard likely open
							handleKeyboardShow();
						} else {
							handleKeyboardHide();
						}
					}
					
					if (window.visualViewport) {
						window.visualViewport.addEventListener('resize', checkKeyboard);
					} else {
						window.addEventListener('resize', checkKeyboard);
					}
				}
				
				// Android keyboard detection
				window.addEventListener('resize', () => {
					const heightDifference = window.screen.height - window.innerHeight;
					if (heightDifference > 150) {
						handleKeyboardShow();
					} else {
						handleKeyboardHide();
					}
				});
			}
			
			// Geolocation for future features
			function initializeGeolocation() {
				if ('geolocation' in navigator) {
					console.log('üìç Geolocation available');
					// Could be used for ice cream shop finder in future
				}
			}
			
			// Device sensors (if available)
			function initializeDeviceSensors() {
				// Ambient Light Sensor (experimental)
				if ('AmbientLightSensor' in window) {
					try {
						const sensor = new AmbientLightSensor();
						sensor.addEventListener('reading', () => {
							const lux = sensor.illuminance;
							console.log(`üí° Ambient light: ${lux} lux`);
							
							// Adjust theme based on ambient light
							if (lux < 10) {
								document.body.classList.add('dark-environment');
							} else {
								document.body.classList.remove('dark-environment');
							}
						});
						sensor.start();
					} catch (error) {
						console.log('üí° Ambient light sensor not available');
					}
				}
			}
			
			// Share API integration
			function enhanceSharing() {
				const shareButton = document.getElementById('share-btn');
				
				if ('share' in navigator && shareButton) {
					shareButton.addEventListener('click', async (e) => {
						e.preventDefault();
						
						const sessionUrl = generateShareableUrl(currentSessionId);
						
						try {
							await navigator.share({
								title: 'üç¶ D√≥nde Est√° Mi Helado?',
								text: '√önete a mi sesi√≥n de helados! üç®',
								url: sessionUrl
							});
							
							console.log('üì± Native sharing completed');
							triggerHapticFeedback('success');
						} catch (error) {
							console.log('üì± Native sharing cancelled or failed');
							// Fallback to clipboard
							copyShareURL();
						}
					});
				}
			}
			
			// Initialize device integration features
			function initializeDeviceIntegration() {
				handleOrientationChange();
				monitorNetworkStatus();
				monitorBatteryStatus();
				monitorDeviceMemory();
				handleMobileKeyboard();
				initializeGeolocation();
				initializeDeviceSensors();
				enhanceSharing();
				
				// Request wake lock when app becomes visible
				document.addEventListener('visibilitychange', () => {
					if (!document.hidden) {
						requestWakeLock();
					} else if (wakeLock) {
						wakeLock.release();
						wakeLock = null;
					}
				});
				
				console.log('üì± Device integration features initialized');
			}
			
			initializeDeviceIntegration();
			});

			// Save data and clean up listeners before page unload
			window.addEventListener('beforeunload', () => {
				// Clean up Firebase listeners
				if (firebaseListenersCleanup) {
					firebaseListenersCleanup();
				}
				// Final save
				saveFlavors();
			});
		</script>

		<!-- Custom CSS for additional animations and PWA native experience -->
		<style>
			/* PWA Native App Enhancements */
			html, body {
				-webkit-overflow-scrolling: touch;
				overscroll-behavior: none;
				-webkit-touch-callout: none;
				-webkit-tap-highlight-color: transparent;
				touch-action: manipulation;
			}
			
			/* Allow text selection in input fields only */
			.flavor-input {
				-webkit-user-select: text;
				-moz-user-select: text;
				-ms-user-select: text;
				user-select: text;
			}
			
			/* PWA Safe Area Support */
			body {
				padding-top: max(20px, var(--safe-area-inset-top));
				padding-left: var(--safe-area-inset-left);
				padding-right: var(--safe-area-inset-right);
				padding-bottom: var(--safe-area-inset-bottom);
			}
			
			/* Native-style button interactions */
			button, .clickable {
				-webkit-tap-highlight-color: transparent;
				touch-action: manipulation;
				cursor: pointer;
			}
			
			button:active, .clickable:active {
				transform: scale(0.97);
				transition: transform 0.1s ease-in-out;
			}
			
			/* Native-style form inputs */
			.flavor-input {
				-webkit-appearance: none;
				appearance: none;
				border-radius: 12px;
				font-size: 16px; /* Prevents zoom on iOS */
				transition: all 0.2s ease;
			}

			@keyframes fade-in {
				from {
					opacity: 0;
					transform: translateY(-10px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			@keyframes slide-up {
				from {
					opacity: 0;
					transform: translateY(30px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}
			
			@keyframes pulse-gentle {
				0%, 100% {
					transform: scale(1);
				}
				50% {
					transform: scale(1.02);
				}
			}

			.animate-fade-in {
				animation: fade-in 0.8s ease-out;
			}

			.animate-slide-up {
				animation: slide-up 0.6s ease-out 0.2s both;
			}
			
			.animate-pulse-gentle {
				animation: pulse-gentle 2s ease-in-out infinite;
			}

			/* Enhanced scroll behavior */
			html {
				scroll-behavior: smooth;
			}

			/* Custom focus styles for better accessibility */
			.flavor-input:focus {
				outline: none;
				transform: translateY(-1px);
				box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
			}

			/* Backdrop blur support fallback */
			@supports not (backdrop-filter: blur(12px)) {
				.backdrop-blur-sm {
					background: rgba(255, 255, 255, 0.9);
				}
			}
			
			/* PWA Standalone mode detection */
			@media (display-mode: standalone) {
				body {
					background-attachment: fixed;
				}
				
				/* Hide scrollbars in PWA mode for cleaner look */
				::-webkit-scrollbar {
					display: none;
				}
				
				* {
					-ms-overflow-style: none;
					scrollbar-width: none;
				}
				
				/* Add subtle shadow to indicate app boundaries */
				.container {
					box-shadow: 0 0 30px rgba(0, 0, 0, 0.1);
				}
			}
			
			/* iOS specific adjustments */
			@supports (-webkit-touch-callout: none) {
				.ios-safe-top {
					padding-top: max(20px, var(--safe-area-inset-top));
				}
				
				/* iOS status bar integration */
				@media (display-mode: standalone) {
					body {
						background: linear-gradient(135deg, #EBF4FF 0%, #E0E7FF 50%, #FCE7F3 100%);
					}
				}
			}
			
			/* Haptic feedback simulation */
			@keyframes haptic-light {
				0% { transform: scale(1); }
				50% { transform: scale(0.98); }
				100% { transform: scale(1); }
			}
			
			.haptic-feedback {
				animation: haptic-light 0.1s ease-out;
			}
			
			/* Phase 8.7: Platform-Specific Optimizations */
			
			/* iOS Specific Enhancements */
			@supports (-webkit-touch-callout: none) {
				/* iOS Safari specific styles */
				.ios-safe-top {
					padding-top: max(20px, var(--safe-area-inset-top));
				}
				
				/* iOS status bar integration */
				@media (display-mode: standalone) {
					body {
						background: linear-gradient(135deg, #EBF4FF 0%, #E0E7FF 50%, #FCE7F3 100%);
					}
					
					/* iOS app-like navigation */
					.container {
						max-width: 100%;
						padding-left: var(--safe-area-inset-left);
						padding-right: var(--safe-area-inset-right);
					}
				}
				
				/* iOS keyboard adjustments */
				.keyboard-open .container {
					transform: translateY(-10px);
					transition: transform 0.3s ease;
				}
				
				/* iOS scroll bounce prevention */
				body {
					-webkit-overflow-scrolling: touch;
					overscroll-behavior-y: none;
				}
			}
			
			/* Android Specific Enhancements */
			@supports not (-webkit-touch-callout: none) {
				/* Android Chrome specific styles */
				@media (display-mode: standalone) {
					/* Android navigation bar color */
					meta[name="theme-color"] {
						content: "#3B82F6";
					}
					
					/* Android Material Design shadows */
					.bg-white\/80 {
						box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
					}
					
					/* Android ripple effects */
					button:active::after {
						content: '';
						position: absolute;
						inset: 0;
						background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
						border-radius: inherit;
						animation: ripple 0.3s ease-out;
					}
				}
			}
			
			/* Landscape mode optimizations */
			.landscape-mode .container {
				max-width: 100%;
				display: flex;
				flex-direction: row;
				gap: 2rem;
				align-items: flex-start;
			}
			
			.landscape-mode header {
				flex: 0 0 300px;
			}
			
			.landscape-mode main {
				flex: 1;
			}
			
			/* Low memory device optimizations */
			.low-memory-mode .animate-pulse-gentle {
				animation: none;
			}
			
			.low-memory-mode .backdrop-blur-sm {
				backdrop-filter: none;
				background: rgba(255, 255, 255, 0.95);
			}
			
			/* Dark environment adjustments */
			.dark-environment {
				filter: brightness(0.8);
			}
			
			.dark-environment .bg-white\/80 {
				background: rgba(255, 255, 255, 0.9);
			}
			
			/* Phase 8.8: Final Polish */
			
			/* App store ready optimizations */
			@media (prefers-reduced-motion: reduce) {
				*, *::before, *::after {
					animation-duration: 0.01ms !important;
					animation-iteration-count: 1 !important;
					transition-duration: 0.01ms !important;
				}
			}
			
			/* High contrast mode support */
			@media (prefers-contrast: high) {
				.bg-white\/80 {
					background: rgba(255, 255, 255, 1);
					border: 2px solid #000;
				}
				
				.text-gray-600 {
					color: #000;
				}
			}
			
			/* Print styles for debugging */
			@media print {
				body {
					background: white !important;
				}
				
				.fixed, .absolute {
					position: static !important;
				}
			}
			
			/* App screenshot optimization */
			@media (max-width: 375px) and (max-height: 812px) {
				/* iPhone X/11/12 screenshot optimization */
				.container {
					padding-top: 2rem;
					padding-bottom: 2rem;
				}
			}
			
			/* Accessibility enhancements */
			@media (prefers-reduced-motion: no-preference) {
				html {
					scroll-behavior: smooth;
				}
			}
			
			/* Focus visible for keyboard navigation */
			button:focus-visible,
			.flavor-input:focus-visible {
				outline: 2px solid #3B82F6;
				outline-offset: 2px;
			}
			
			/* Screen reader only text */
			.sr-only {
				position: absolute;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0, 0, 0, 0);
				white-space: nowrap;
				border: 0;
			}
			
			/* Loading state optimizations */
			#app-loading {
				will-change: opacity, transform;
			}
			
			/* Context menu improvements */
			.context-menu {
				backdrop-filter: blur(20px);
				-webkit-backdrop-filter: blur(20px);
				border: 1px solid rgba(255, 255, 255, 0.2);
			}
		</style>
	</body>
</html>
