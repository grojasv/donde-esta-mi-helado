---
// Import global styles with Tailwind CSS
import '../styles/global.css';
// Import the reusable IceCreamContainer component
import IceCreamContainer from '../components/IceCreamContainer.astro';

// Get git commit information for version tracking
import { execSync } from 'child_process';

let gitInfo = {
	hash: 'unknown',
	message: 'Local build',
	date: new Date().toISOString(),
	branch: 'unknown'
};

try {
	// Get current commit hash (short)
	gitInfo.hash = execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).trim();
	
	// Get commit message
	gitInfo.message = execSync('git log -1 --pretty=%s', { encoding: 'utf-8' }).trim();
	
	// Get commit date
	gitInfo.date = execSync('git log -1 --pretty=%cI', { encoding: 'utf-8' }).trim();
	
	// Get current branch
	gitInfo.branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
} catch (error) {
	console.warn('Could not get git information:', error.message);
}

// Format build timestamp
const buildTime = new Date().toISOString();

// Get Firebase environment variables for client-side use
// These will be passed to the browser as inline JavaScript variables
const firebaseEnvVars = {
	apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY || null,
	authDomain: import.meta.env.PUBLIC_FIREBASE_AUTH_DOMAIN || null,
	databaseURL: import.meta.env.PUBLIC_FIREBASE_DATABASE_URL || null,
	projectId: import.meta.env.PUBLIC_FIREBASE_PROJECT_ID || null,
	storageBucket: import.meta.env.PUBLIC_FIREBASE_STORAGE_BUCKET || null,
	messagingSenderId: import.meta.env.PUBLIC_FIREBASE_MESSAGING_SENDER_ID || null,
	appId: import.meta.env.PUBLIC_FIREBASE_APP_ID || null
};
---

<html lang="es">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="generator" content={Astro.generator} />
		<meta name="description" content="Track your ice cream flavors easily - D√≥nde Est√° Mi Helado?" />
		<title>D√≥nde Est√° Mi Helado?</title>
	</head>
	<body class="bg-gradient-to-br from-blue-50 via-indigo-50 to-pink-50 min-h-screen transition-all duration-300">
		<!-- Main container with enhanced mobile-first design -->
		<div class="container mx-auto px-3 sm:px-4 py-6 sm:py-8 max-w-md">
			<!-- App header with improved animations -->
			<header class="text-center mb-10 animate-fade-in">
				<h1 class="text-4xl font-bold text-gray-800 mb-3 tracking-tight">
					üç¶ D√≥nde Est√° Mi Helado?
				</h1>
				<p class="text-gray-600 text-base leading-relaxed">
					No te olvides de tus sabores favoritos
				</p>
				<div class="w-16 h-1 bg-gradient-to-r from-pink-300 to-blue-300 rounded-full mx-auto mt-4"></div>
			</header>

			<!-- Main content area with enhanced design -->
			<main class="animate-slide-up">
				<div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-xl border border-white/50 p-4 sm:p-6 md:p-8">
					<!-- Enhanced instructions -->
					<div class="mb-6 sm:mb-8 text-center">
						<p class="text-gray-700 text-base leading-relaxed">
							Escribe el sabor de cada helado en el campo correspondiente
						</p>
					</div>

					<!-- Enhanced ice cream containers grid -->
					<div class="space-y-3 sm:space-y-4 md:space-y-5">
						<!-- Container A - Grey with Letter A -->
						<IceCreamContainer 
							containerId="A"
							containerType="letter"
							letter="A"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container B - Grey with Letter B -->
						<IceCreamContainer 
							containerId="B"
							containerType="letter"
							letter="B"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container C - Grey with Letter C -->
						<IceCreamContainer 
							containerId="C"
							containerType="letter"
							letter="C"
							bgGradient="bg-gradient-to-r from-gray-50 to-gray-100"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-300 to-gray-400"
							lidBgGradient="bg-gradient-to-br from-gray-400 to-gray-500"
							inputBorderColor="border-gray-300"
							inputFocusRing="focus:ring-gray-400"
						/>

						<!-- Container 4 - Plain Green -->
						<IceCreamContainer 
							containerId="4"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-green-50 to-emerald-50"
							borderColor="border-green-200"
							hoverBorderColor="hover:border-green-300"
							visualBgGradient="bg-gradient-to-br from-green-200 to-green-300"
							lidBgGradient="bg-gradient-to-br from-green-500 to-emerald-600"
							inputBorderColor="border-green-200"
							inputFocusRing="focus:ring-green-400"
						/>

						<!-- Container 5 - Plain Turquoise -->
						<IceCreamContainer 
							containerId="5"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-cyan-50 to-teal-50"
							borderColor="border-cyan-200"
							hoverBorderColor="hover:border-cyan-300"
							visualBgGradient="bg-gradient-to-br from-cyan-200 to-cyan-300"
							lidBgGradient="bg-gradient-to-br from-cyan-500 to-teal-600"
							inputBorderColor="border-cyan-200"
							inputFocusRing="focus:ring-cyan-400"
						/>

						<!-- Container 6 - Plain Pink -->
						<IceCreamContainer 
							containerId="6"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-pink-50 to-rose-50"
							borderColor="border-pink-200"
							hoverBorderColor="hover:border-pink-300"
							visualBgGradient="bg-gradient-to-br from-pink-200 to-pink-300"
							lidBgGradient="bg-gradient-to-br from-pink-500 to-rose-600"
							inputBorderColor="border-pink-200"
							inputFocusRing="focus:ring-pink-400"
						/>

						<!-- Container 7 - Plain Light Grey -->
						<IceCreamContainer 
							containerId="7"
							containerType="plain"
							bgGradient="bg-gradient-to-r from-gray-50 to-slate-50"
							borderColor="border-gray-200"
							hoverBorderColor="hover:border-gray-300"
							visualBgGradient="bg-gradient-to-br from-gray-200 to-gray-300"
							lidBgGradient="bg-gradient-to-br from-gray-300 to-slate-400"
							inputBorderColor="border-gray-200"
							inputFocusRing="focus:ring-gray-400"
						/>
					</div>

					<!-- Enhanced status message with share functionality -->
					<div class="mt-6 sm:mt-8 text-center space-y-3 sm:space-y-4">
						<p id="save-status" class="text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300">
							<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
							</svg>
							Los cambios se guardar√°n autom√°ticamente
						</p>
						
						<!-- Share button -->
						<button 
							id="share-btn"
							class="hidden px-6 py-2 bg-gradient-to-r from-pink-500 to-purple-500 text-white rounded-lg hover:from-pink-600 hover:to-purple-600 transition-all duration-300 transform hover:scale-105 shadow-lg hover:shadow-xl"
						>
							<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
								<path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"></path>
							</svg>
							Compartir Sabores
						</button>
					</div>
				</div>
			</main>
		</div>

		<!-- Elegant version footer -->
		<footer class="container mx-auto px-3 sm:px-4 py-4 max-w-md">
			<div class="bg-white/40 backdrop-blur-sm rounded-xl border border-white/30 p-3 text-center shadow-sm">
				<div class="flex flex-col sm:flex-row items-center justify-center gap-2 text-xs text-gray-600">
					<!-- Git commit info -->
					<div class="flex items-center gap-2">
						<svg class="w-3 h-3 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265L11.764 7h4.236a1 1 0 01.949 1.316l-2 6A1 1 0 0114 15h-3.236l.949 2.684a1 1 0 01-1.898.632L8.236 15H4a1 1 0 01-.949-1.316l2-6A1 1 0 016 7h3.236l-.949-2.684a1 1 0 011.898-.632L12.316 3.051z" clip-rule="evenodd"></path>
						</svg>
						<span class="font-mono">#{gitInfo.hash}</span>
						<span class="hidden sm:inline text-gray-400">‚Ä¢</span>
					</div>
					
					<!-- Commit message (truncated on mobile) -->
					<div class="text-center sm:text-left">
						<span class="block sm:inline max-w-40 sm:max-w-none truncate" title={gitInfo.message}>
							{gitInfo.message.length > 30 ? gitInfo.message.substring(0, 30) + '...' : gitInfo.message}
						</span>
					</div>
					
					<!-- Build timestamp -->
					<div class="flex items-center gap-1 text-gray-500">
						<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
						</svg>
						<time class="font-mono text-xs" datetime={buildTime} title={`Built: ${new Date(buildTime).toLocaleString()}`}>
							{new Date(buildTime).toLocaleDateString('es-ES', { 
								month: 'short', 
								day: 'numeric', 
								hour: '2-digit', 
								minute: '2-digit'
							})}
						</time>
					</div>
				</div>
				
				<!-- Branch indicator (only show if not main) -->
				{gitInfo.branch !== 'main' && (
					<div class="mt-2 pt-2 border-t border-gray-200/50">
						<span class="inline-flex items-center gap-1 px-2 py-1 text-xs font-medium text-amber-800 bg-amber-100/80 rounded-full">
							<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M6 6V5a3 3 0 013-3h2a3 3 0 013 3v1h2a2 2 0 012 2v3.57A22.952 22.952 0 0110 13a22.95 22.95 0 01-8-1.43V8a2 2 0 012-2h2zM2.93 17.5c-.84.76-2.13.75-2.93.04V15.8c.55.34 1.23.5 1.93.5.7 0 1.38-.16 1.93-.5v1.74c0 .15-.06.3-.17.41l-.76.75z" clip-rule="evenodd"></path>
							</svg>
							branch: {gitInfo.branch}
						</span>
					</div>
				)}
			</div>
		</footer>

		<!-- Enhanced client-side JavaScript with Firebase real-time sync (Inlined) -->
		<script type="module" define:vars={{ firebaseEnvVars }}>
			// Firebase imports (using CDN to avoid build issues)
			import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
			import { getDatabase, ref, set, get, onValue, off } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js';

			// ========================================
			// FIREBASE CONFIGURATION & INITIALIZATION  
			// ========================================
			
			// Firebase configuration from server-side environment variables
			// Using Astro's define:vars to safely pass server variables to client
			const firebaseConfig = {
				apiKey: firebaseEnvVars.apiKey,
				authDomain: firebaseEnvVars.authDomain,
				databaseURL: firebaseEnvVars.databaseURL,
				projectId: firebaseEnvVars.projectId,
				storageBucket: firebaseEnvVars.storageBucket,
				messagingSenderId: firebaseEnvVars.messagingSenderId,
				appId: firebaseEnvVars.appId
			};

			// Validate that all required environment variables are present
			const requiredConfigKeys = ['apiKey', 'authDomain', 'databaseURL', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
			const missingVars = requiredConfigKeys.filter(key => !firebaseConfig[key] || firebaseConfig[key] === null || firebaseConfig[key] === 'null');

			let database = null;
			let isFirebaseInitialized = false;

			if (missingVars.length > 0) {
				console.warn('‚ö†Ô∏è Missing Firebase environment variables:', missingVars);
				console.warn('üìù Firebase will be disabled. App will use localStorage only.');
				console.warn('üîß Please check your Netlify environment variables or local .env file');
			} else {
				try {
					// Initialize Firebase
					const app = initializeApp(firebaseConfig);
					database = getDatabase(app);
					isFirebaseInitialized = true;
					console.log('üî• Firebase initialized successfully');
				} catch (error) {
					console.error('‚ùå Firebase initialization failed:', error);
					console.log('üì¶ Falling back to localStorage only');
				}
			}

			// ========================================
			// SESSION MANAGEMENT FUNCTIONS
			// ========================================
			
			function generateSessionId() {
				const timestamp = Date.now().toString();
				const randomSuffix = Math.random().toString(36).substring(2, 8);
				return `ice${timestamp}${randomSuffix}`;
			}

			function isValidSessionId(sessionId) {
				if (!sessionId || typeof sessionId !== 'string') {
					return false;
				}
				const sessionRegex = /^ice[a-zA-Z0-9]{16,}$/;
				return sessionRegex.test(sessionId);
			}

			function getCurrentSessionId() {
				const urlParams = new URLSearchParams(window.location.search);
				const sessionId = urlParams.get('session');
				return (sessionId && isValidSessionId(sessionId)) ? sessionId : null;
			}

			function updateUrlWithSession(sessionId) {
				if (!isValidSessionId(sessionId)) {
					console.error('Invalid session ID provided:', sessionId);
					return;
				}
				const newUrl = `${window.location.pathname}?session=${sessionId}`;
				window.history.pushState({ sessionId }, '', newUrl);
				console.log(`üîó Updated URL with session: ${sessionId}`);
			}

			function clearSessionFromUrl() {
				window.history.pushState({}, document.title, window.location.pathname);
				console.log('üßπ Cleared session from URL - switched to local mode');
			}

			function generateShareableUrl(sessionId) {
				if (!isValidSessionId(sessionId)) {
					throw new Error('Invalid session ID provided');
				}
				return `${window.location.origin}${window.location.pathname}?session=${sessionId}`;
			}

			function getOrCreateSessionId() {
				const urlSessionId = getCurrentSessionId();
				if (urlSessionId) {
					console.log(`üì± Using existing session from URL: ${urlSessionId}`);
					return urlSessionId;
				}
				
				const newSessionId = generateSessionId();
				console.log(`üÜï Generated new session ID: ${newSessionId}`);
				updateUrlWithSession(newSessionId);
				return newSessionId;
			}

			// ========================================
			// FIREBASE DATA MANAGEMENT FUNCTIONS
			// ========================================
			
			function getSessionRef(sessionId, dataType = '') {
				const basePath = `sessions/${sessionId}`;
				return dataType ? ref(database, `${basePath}/${dataType}`) : ref(database, basePath);
			}

			async function saveFlavorsToFirebase(sessionId, flavors) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const flavorsRef = getSessionRef(sessionId, 'flavors');
					await set(flavorsRef, flavors);
					
					const metadataRef = getSessionRef(sessionId, 'metadata');
					await set(metadataRef, {
						lastUpdated: Date.now(),
						version: '1.0'
					});
					
					console.log(`‚úÖ Flavors saved to Firebase session: ${sessionId}`);
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					return true;
				} catch (error) {
					console.error('‚ùå Error saving flavors to Firebase:', error);
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					throw error;
				}
			}

			async function saveFillLevelsToFirebase(sessionId, fillLevels) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
					await set(fillLevelsRef, fillLevels);
					console.log(`‚úÖ Fill levels saved to Firebase session: ${sessionId}`);
					localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
					return true;
				} catch (error) {
					console.error('‚ùå Error saving fill levels to Firebase:', error);
					localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
					throw error;
				}
			}

			async function loadFlavorsFromFirebase(sessionId) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const flavorsRef = getSessionRef(sessionId, 'flavors');
					const snapshot = await get(flavorsRef);
					
					if (snapshot.exists()) {
						const flavors = snapshot.val();
						console.log(`üì• Flavors loaded from Firebase session: ${sessionId}`);
						localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
						return flavors;
					} else {
						console.log(`üì≠ No flavors found in Firebase session: ${sessionId}`);
						return {};
					}
				} catch (error) {
					console.error('‚ùå Error loading flavors from Firebase:', error);
					
					try {
						const savedFlavors = localStorage.getItem(STORAGE_KEY);
						if (savedFlavors) {
							console.log('üì¶ Using localStorage fallback for flavors');
							return JSON.parse(savedFlavors);
						}
					} catch (localError) {
						console.error('‚ùå Error loading from localStorage:', localError);
					}
					
					return {};
				}
			}

			async function loadFillLevelsFromFirebase(sessionId) {
				if (!isFirebaseInitialized) {
					throw new Error('Firebase not initialized');
				}
				
				try {
					const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
					const snapshot = await get(fillLevelsRef);
					
					if (snapshot.exists()) {
						const fillLevels = snapshot.val();
						console.log(`üì• Fill levels loaded from Firebase session: ${sessionId}`);
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
						return fillLevels;
					} else {
						console.log(`üì≠ No fill levels found in Firebase session: ${sessionId}`);
						return {};
					}
				} catch (error) {
					console.error('‚ùå Error loading fill levels from Firebase:', error);
					
					try {
						const savedFillLevels = localStorage.getItem(FILL_LEVELS_KEY);
						if (savedFillLevels) {
							console.log('üì¶ Using localStorage fallback for fill levels');
							return JSON.parse(savedFillLevels);
						}
					} catch (localError) {
						console.error('‚ùå Error loading from localStorage:', localError);
					}
					
					return {};
				}
			}

			function setupRealtimeListeners(sessionId, onFlavorsChange, onFillLevelsChange) {
				if (!isFirebaseInitialized) {
					console.log('‚ö†Ô∏è Firebase not available - real-time sync disabled');
					return () => {}; // Return empty cleanup function
				}
				
				const flavorsRef = getSessionRef(sessionId, 'flavors');
				const fillLevelsRef = getSessionRef(sessionId, 'fillLevels');
				
				const flavorsUnsubscribe = onValue(flavorsRef, (snapshot) => {
					if (snapshot.exists()) {
						const flavors = snapshot.val();
						console.log(`üîÑ Real-time flavors update received for session: ${sessionId}`);
						localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
						if (onFlavorsChange) {
							onFlavorsChange(flavors);
						}
					}
				}, (error) => {
					console.error('‚ùå Error in flavors listener:', error);
				});
				
				const fillLevelsUnsubscribe = onValue(fillLevelsRef, (snapshot) => {
					if (snapshot.exists()) {
						const fillLevels = snapshot.val();
						console.log(`üîÑ Real-time fill levels update received for session: ${sessionId}`);
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(fillLevels));
						if (onFillLevelsChange) {
							onFillLevelsChange(fillLevels);
						}
					}
				}, (error) => {
					console.error('‚ùå Error in fill levels listener:', error);
				});
				
				console.log(`üëÇ Real-time listeners set up for session: ${sessionId}`);
				
				return () => {
					console.log(`üëã Cleaning up listeners for session: ${sessionId}`);
					flavorsUnsubscribe();
					fillLevelsUnsubscribe();
				};
			}

			async function isFirebaseAvailable() {
				if (!isFirebaseInitialized) {
					console.log('üîå Firebase not initialized');
					return false;
				}
				
				try {
					// Test Firebase connectivity by trying a simple read
					const testRef = ref(database, '.info/serverTimeOffset');
					const snapshot = await get(testRef);
					console.log('üî• Firebase connectivity test passed');
					return true;
				} catch (error) {
					console.log('üîå Firebase connectivity test failed:', error.message);
					// Even if connectivity test fails, Firebase might still work
					// Let's return true if Firebase is initialized properly
					return isFirebaseInitialized;
				}
			}

			// Global session and state management
			let currentSessionId = null;
			let firebaseListenersCleanup = null;
			let isOnline = true;
			
			// Legacy storage keys for localStorage fallback
			const STORAGE_KEY = 'donde-esta-mi-helado-flavors';
			const FILL_LEVELS_KEY = 'donde-esta-mi-helado-fill-levels';

			// Creamy ice cream colors for realistic variety
			const ICE_CREAM_COLORS = [
				'from-amber-100 to-yellow-100',     // Vanilla cream
				'from-pink-100 to-rose-200',       // Strawberry
				'from-orange-100 to-amber-200',    // Peach
				'from-green-100 to-emerald-200',   // Mint chip
				'from-purple-100 to-violet-200',   // Lavender
				'from-yellow-100 to-amber-100',    // Banana
				'from-orange-200 to-yellow-200',   // Mango
				'from-pink-200 to-red-200',        // Cherry
				'from-green-200 to-lime-200',      // Pistachio
				'from-blue-100 to-cyan-200',       // Bubblegum
				'from-gray-100 to-slate-200',      // Cookies & cream
				'from-amber-200 to-orange-200',    // Caramel
				'from-indigo-100 to-blue-200',     // Blueberry
				'from-lime-100 to-green-200',      // Lime
				'from-rose-100 to-pink-200'        // Cotton candy
			];

			// Function to get random ice cream color
			function getRandomIceCreamColor() {
				return ICE_CREAM_COLORS[Math.floor(Math.random() * ICE_CREAM_COLORS.length)];
			}

			// Fill level states
			const FILL_LEVELS = {
				EMPTY: 0,
				HALF: 35,
				FULL: 80
			};

			// Global state for fill levels
			let containerFillLevels = {};

			// Initialize session and setup Firebase real-time sync
			async function initializeSession() {
				try {
					// Check if Firebase is available
					isOnline = await isFirebaseAvailable();
					console.log(`üîå Firebase status: ${isOnline ? 'online' : 'offline'}`);
					
					// Get or create session ID
					currentSessionId = getOrCreateSessionId();
					console.log(`üéØ Current session: ${currentSessionId}`);
					
					// Load initial data from Firebase (or localStorage if offline)
					await loadInitialData();
					
					// Set up real-time listeners if online
					if (isOnline && currentSessionId) {
						setupFirebaseListeners();
					}
					
					// Update UI to reflect session status
					updateSessionUI();
					
				} catch (error) {
					console.error('‚ùå Error initializing session:', error);
					// Fallback to localStorage mode
					await loadLocalStorageData();
				}
			}
			
			// Load initial data from Firebase or localStorage
			async function loadInitialData() {
				if (!currentSessionId) {
					await loadLocalStorageData();
					return;
				}
				
				try {
					// Load flavors and fill levels from Firebase
					const [flavors, fillLevels] = await Promise.all([
						loadFlavorsFromFirebase(currentSessionId),
						loadFillLevelsFromFirebase(currentSessionId)
					]);
					
					// Apply loaded data to UI
					applyFlavorsToUI(flavors);
					containerFillLevels = fillLevels || {};
					
					// Update visual states
					setTimeout(() => updateContainerVisuals(), 100);
					
					console.log('‚úÖ Initial data loaded from Firebase');
					
				} catch (error) {
					console.error('‚ùå Error loading from Firebase:', error);
					// Fallback to localStorage
					await loadLocalStorageData();
				}
			}
			
			// Fallback function to load from localStorage
			async function loadLocalStorageData() {
				try {
					console.log('üì¶ Loading from localStorage...');
					console.log('Storage keys:', {STORAGE_KEY, FILL_LEVELS_KEY});
					
					// Load flavors from localStorage
					const savedFlavors = localStorage.getItem(STORAGE_KEY);
					console.log('Saved flavors:', savedFlavors);
					
					if (savedFlavors) {
						const flavors = JSON.parse(savedFlavors);
						console.log('Parsed flavors:', flavors);
						applyFlavorsToUI(flavors);
					} else {
						console.log('No saved flavors found in localStorage');
					}
					
					// Load fill levels from localStorage
					const savedFillLevels = localStorage.getItem(FILL_LEVELS_KEY);
					console.log('Saved fill levels:', savedFillLevels);
					
					if (savedFillLevels) {
						containerFillLevels = JSON.parse(savedFillLevels);
						console.log('Parsed fill levels:', containerFillLevels);
					} else {
						console.log('No saved fill levels found in localStorage');
					}
					
					// Update visual states
					setTimeout(() => updateContainerVisuals(), 100);
					
					console.log('‚úÖ Data loaded from localStorage successfully');
					
				} catch (error) {
					console.error('‚ùå Error loading from localStorage:', error);
				}
			}
			
			// Apply flavors data to UI inputs
			function applyFlavorsToUI(flavors) {
				Object.keys(flavors).forEach(containerId => {
					const input = document.getElementById(`flavor-${containerId}`);
					if (input && flavors[containerId]) {
						input.value = flavors[containerId];
						// Add animation for loaded flavors
						input.classList.add('animate-pulse');
						setTimeout(() => input.classList.remove('animate-pulse'), 300);
					}
				});
			}

			// Setup Firebase real-time listeners for session data changes
			function setupFirebaseListeners() {
				if (!currentSessionId || firebaseListenersCleanup) {
					return; // Already set up or no session
				}
				
				console.log(`üëÇ Setting up Firebase listeners for session: ${currentSessionId}`);
				
				// Set up real-time listeners with callbacks
				firebaseListenersCleanup = setupRealtimeListeners(
					currentSessionId,
					// On flavors change callback
					(flavors) => {
						console.log('üîÑ Firebase flavors update received');
						applyFlavorsToUI(flavors);
						updateContainerVisuals();
						updateShareButton();
						updateEatButtons();
						showSyncStatus('synced');
					},
					// On fill levels change callback
					(fillLevels) => {
						console.log('üîÑ Firebase fill levels update received');
						containerFillLevels = fillLevels || {};
						updateContainerVisuals();
						showSyncStatus('synced');
					}
				);
			}
			
			// Enhanced function to save fill levels to Firebase and localStorage
			async function saveFillLevels() {
				try {
					// Save to Firebase if online and session exists
					if (isOnline && currentSessionId) {
						try {
							await saveFillLevelsToFirebase(currentSessionId, containerFillLevels);
							showSyncStatus('synced');
						} catch (error) {
							console.error('‚ùå Error saving fill levels to Firebase:', error);
							showSyncStatus('error');
							// Fallback to localStorage
							localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(containerFillLevels));
						}
					} else {
						// Save to localStorage only
						localStorage.setItem(FILL_LEVELS_KEY, JSON.stringify(containerFillLevels));
						showSyncStatus('offline');
					}
				} catch (error) {
					console.error('‚ùå Error saving fill levels:', error);
					showSyncStatus('error');
				}
			}

			// Enhanced function to save flavors to Firebase and localStorage  
			async function saveFlavors() {
				console.log('üöÄ saveFlavors() function called');
				try {
					const flavors = {};
					const inputs = document.querySelectorAll('.flavor-input');
					console.log(`üìã Found ${inputs.length} flavor inputs to process`);
					
					inputs.forEach((input, index) => {
						const containerId = input.dataset.container;
						const value = input.value.trim();
						console.log(`Input ${index}: container=${containerId}, value="${value}"`);
						if (containerId && value) {
							flavors[containerId] = value;
						}
					});
					
					console.log('üíæ Final flavors object to save:', flavors);
					console.log('üî• Firebase status:', {isOnline, currentSessionId, isFirebaseInitialized});
					
					// Always save to localStorage as backup
					localStorage.setItem(STORAGE_KEY, JSON.stringify(flavors));
					console.log('‚úÖ Flavors saved to localStorage');
					
					// Also try to save to Firebase if online and session exists
					if (isOnline && isFirebaseInitialized && currentSessionId) {
						try {
							console.log('üîÑ Attempting Firebase save...');
							await saveFlavorsToFirebase(currentSessionId, flavors);
							console.log('‚úÖ Flavors saved to Firebase');
							showSyncStatus('synced');
						} catch (error) {
							console.error('‚ùå Error saving to Firebase:', error);
							console.error('Firebase error details:', error.message);
							showSyncStatus('error');
						}
					} else {
						console.log('üì¶ Firebase not available - using localStorage only');
						showSyncStatus('offline');
					}
					
					// Enhanced save confirmation with smooth animation
					const status = document.getElementById('save-status');
					if (status) {
						status.innerHTML = `
							<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
							</svg>
							Guardado autom√°ticamente
						`;
						status.className = 'text-sm text-green-600 flex items-center justify-center gap-2 transition-all duration-300 transform scale-105';
						
						// Reset status message with smooth transition
						setTimeout(() => {
							status.innerHTML = `
								<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
									<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
								</svg>
								Los cambios se guardar√°n autom√°ticamente
							`;
							status.className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
						}, 2500);
					}
					
					console.log('‚úÖ Flavors saved to localStorage');
				} catch (error) {
					console.error('‚ùå Error saving flavors:', error);
					
					// Enhanced error message
					const status = document.getElementById('save-status');
					if (status) {
						status.innerHTML = `
							<svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
								<path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
							</svg>
							Error al guardar
						`;
						status.className = 'text-sm text-red-600 flex items-center justify-center gap-2 transition-all duration-300';
						
						setTimeout(() => {
							status.innerHTML = `
								<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
									<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
								</svg>
								Los cambios se guardar√°n autom√°ticamente
							`;
							status.className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
						}, 3000);
					}
				}
			}

			// Debounce function to avoid too frequent saves
			function debounce(func, wait) {
				let timeout;
				return function executedFunction(...args) {
					console.log(`‚è∞ Debounce function called, will execute in ${wait}ms`);
					const later = () => {
						clearTimeout(timeout);
						console.log(`‚ö° Debounce timeout completed, executing function`);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
				};
			}

			// Show sync status to the user
			function showSyncStatus(status) {
				const statusElement = document.getElementById('save-status');
				if (!statusElement) return;
				
				let icon, message, className;
				
				switch (status) {
					case 'synced':
						icon = `<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
						</svg>`;
						message = currentSessionId ? 'Sincronizado con otros dispositivos' : 'Guardado autom√°ticamente';
						className = 'text-sm text-green-600 flex items-center justify-center gap-2 transition-all duration-300 transform scale-105';
						break;
					case 'offline':
						icon = `<svg class="w-4 h-4 text-orange-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Guardado localmente (sin conexi√≥n)';
						className = 'text-sm text-orange-600 flex items-center justify-center gap-2 transition-all duration-300';
						break;
					case 'error':
						icon = `<svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Error al guardar - reintentando...';
						className = 'text-sm text-red-600 flex items-center justify-center gap-2 transition-all duration-300';
						break;
					default:
						icon = `<svg class="w-4 h-4 opacity-60" fill="currentColor" viewBox="0 0 20 20">
															<path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
						</svg>`;
						message = 'Los cambios se sincronizar√°n autom√°ticamente';
						className = 'text-sm text-gray-500 flex items-center justify-center gap-2 transition-all duration-300';
				}
				
				statusElement.innerHTML = `${icon}${message}`;
				statusElement.className = className;
				
				// Reset to default after a delay
				if (status !== 'default') {
					setTimeout(() => showSyncStatus('default'), 3000);
				}
			}

			// Debounced save function (saves 300ms after user stops typing - faster feedback)
			const debouncedSave = debounce(saveFlavors, 300);

			// Function to copy session share URL to clipboard
			async function copyShareURL() {
				if (!currentSessionId) {
					alert('‚ö†Ô∏è Error: No hay sesi√≥n activa para compartir');
					return;
				}
				
				// Check if there's content to share
				const inputs = document.querySelectorAll('.flavor-input');
				let hasContent = false;
				inputs.forEach(input => {
					if (input.value.trim()) {
						hasContent = true;
					}
				});
				
				if (!hasContent) {
					alert('‚ö†Ô∏è Agrega algunos sabores antes de compartir');
					return;
				}
				
				try {
					const shareURL = generateShareableUrl(currentSessionId);
					await navigator.clipboard.writeText(shareURL);
					
					// Update button text temporarily
					const shareBtn = document.getElementById('share-btn');
					const originalText = shareBtn.innerHTML;
					shareBtn.innerHTML = `
						<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
							<path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
						</svg>
						¬°Copiado!
					`;
					shareBtn.classList.add('from-green-500', 'to-green-600');
					shareBtn.classList.remove('from-pink-500', 'to-purple-500');
					
					setTimeout(() => {
						shareBtn.innerHTML = originalText;
						shareBtn.classList.remove('from-green-500', 'to-green-600');
						shareBtn.classList.add('from-pink-500', 'to-purple-500');
					}, 2000);
					
					console.log(`‚úÖ Session share URL copied: ${shareURL}`);
				} catch (error) {
					console.error('‚ùå Error copying to clipboard:', error);
					// Fallback: show URL in alert
					const shareURL = generateShareableUrl(currentSessionId);
					alert(`üìã Copia este enlace para compartir:\n\n${shareURL}`);
				}
			}
			
			// Update UI to reflect session status
			function updateSessionUI() {
				const shareBtn = document.getElementById('share-btn');
				if (shareBtn && currentSessionId) {
					// Update share button text to reflect session sharing
					shareBtn.innerHTML = `
						<svg class="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
							<path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"></path>
						</svg>
						Compartir Sesi√≥n
					`;
				}
				
				// Show session status if available
				console.log(`üì± Session UI updated - Session: ${currentSessionId || 'none'}, Online: ${isOnline}`);
			}

			// Function to update share button visibility
			function updateShareButton() {
				const shareBtn = document.getElementById('share-btn');
				const inputs = document.querySelectorAll('.flavor-input');
				let hasContent = false;
				
				inputs.forEach(input => {
					if (input.value.trim()) {
						hasContent = true;
					}
				});
				
				if (hasContent) {
					shareBtn.classList.remove('hidden');
				} else {
					shareBtn.classList.add('hidden');
				}
			}

			// Function to update container visual states
			function updateContainerVisuals() {
				const inputs = document.querySelectorAll('.flavor-input');
				inputs.forEach(input => {
					const containerId = input.dataset.container;
					const container = input.closest('.group');
					const iceCreamFill = container.querySelector('.ice-cream-fill');
					const emptyIndicator = container.querySelector('.empty-indicator');
					
					if (input.value.trim()) {
						// Show ice cream fill when there's a flavor
						if (iceCreamFill) {
							// Apply random creamy color if not already set
							if (!iceCreamFill.dataset.colorSet || iceCreamFill.dataset.colorSet === 'false') {
								const randomColor = getRandomIceCreamColor();
								iceCreamFill.className = `ice-cream-fill absolute bottom-0 left-0 right-0 bg-gradient-to-t ${randomColor} transition-all duration-500 rounded-b-xl cursor-pointer z-20`;
								iceCreamFill.dataset.colorSet = 'true';
								console.log(`üé® Applied color to ${containerId}:`, randomColor);
							}
							
							// Get current fill level (default to FULL for new flavors)
							if (!containerFillLevels[containerId]) {
								containerFillLevels[containerId] = FILL_LEVELS.FULL;
							}
							const fillLevel = containerFillLevels[containerId];
							iceCreamFill.style.height = `${fillLevel}%`;
							iceCreamFill.style.opacity = '0.8';
							console.log(`üìä Set fill level for ${containerId} to ${fillLevel}%`);
						}
						
						// Make the ENTIRE ice cream visual container clickable for better UX
						const iceCreamVisual = container.querySelector('.ice-cream-visual');
						if (iceCreamVisual) {
							iceCreamVisual.style.cursor = 'pointer';
							iceCreamVisual.onclick = (e) => {
								e.preventDefault();
								e.stopPropagation();
								console.log(`üñ±Ô∏è Clicked ice cream VISUAL CONTAINER for ${containerId}`);
								toggleFillLevel(containerId);
							};
							console.log(`‚úÖ Added click handler to ENTIRE visual container for ${containerId}`);
						}
						
						if (emptyIndicator) {
							emptyIndicator.style.opacity = '0';
						}
					} else {
						// Show empty state when no flavor
						if (iceCreamFill) {
							iceCreamFill.style.height = '0%';
							iceCreamFill.style.opacity = '0';
							// Reset color and fill level for next flavor
							iceCreamFill.dataset.colorSet = 'false';
							containerFillLevels[containerId] = FILL_LEVELS.EMPTY;
						}
						
						// Remove click handler from visual container
						const iceCreamVisual = container.querySelector('.ice-cream-visual');
						if (iceCreamVisual) {
							iceCreamVisual.style.cursor = '';
							iceCreamVisual.onclick = null;
						}
						
						if (emptyIndicator) {
							emptyIndicator.style.opacity = '1';
						}
					}
				});
			}

			// Function to toggle fill level between FULL and HALF
			function toggleFillLevel(containerId) {
				console.log(`üéØ toggleFillLevel called for ${containerId}`);
				const input = document.getElementById(`flavor-${containerId}`);
				console.log(`üìù Found input:`, input);
				console.log(`üìù Input value:`, input?.value);
				
				if (!input || !input.value.trim()) {
					console.log(`‚ùå No input or empty value for ${containerId}`);
					return; // Only work with containers that have flavors
				}
				
				// Toggle between FULL and HALF
				const currentLevel = containerFillLevels[containerId] || FILL_LEVELS.FULL;
				const newLevel = currentLevel === FILL_LEVELS.FULL ? FILL_LEVELS.HALF : FILL_LEVELS.FULL;
				containerFillLevels[containerId] = newLevel;
				console.log(`üîÑ Toggling from ${currentLevel}% to ${newLevel}%`);
				
				// Update visual immediately
				const container = input.closest('.group');
				const iceCreamFill = container.querySelector('.ice-cream-fill');
				console.log(`üé® Found ice cream fill:`, iceCreamFill);
				
				if (iceCreamFill) {
					iceCreamFill.style.height = `${newLevel}%`;
					console.log(`ü•É Toggled ${containerId} fill level to ${newLevel}%`);
				}
				
				// Save state
				saveFillLevels();
			}

			// Function to update eat button states
			function updateEatButtons() {
				const eatBtns = document.querySelectorAll('.eat-btn');
				eatBtns.forEach(btn => {
					const containerId = btn.dataset.container;
					const input = document.getElementById(`flavor-${containerId}`);
					
					if (input && input.value.trim()) {
						// Enable button when there's a flavor
						btn.disabled = false;
						btn.classList.remove('opacity-0');
						btn.classList.add('opacity-100');
					} else {
						// Disable button when no flavor
						btn.disabled = true;
						btn.classList.remove('opacity-100');
						btn.classList.add('opacity-0');
					}
				});
				
				// Update visual states too
				updateContainerVisuals();
			}

			// Function to eat ice cream with fun animation
			async function eatIceCream(containerId) {
				const input = document.getElementById(`flavor-${containerId}`);
				const container = input.closest('.group');
				const eatBtn = container.querySelector('.eat-btn');
				
				if (!input.value.trim()) return;
				
				// Disable button during animation
				eatBtn.disabled = true;
				eatBtn.classList.add('animate-pulse');
				
				try {
					// Phase 1: Show "eating" animation on button
					eatBtn.innerHTML = 'ü§§';
					await new Promise(resolve => setTimeout(resolve, 300));
					
					// Phase 2: Ice cream drain animation
					const iceCreamFill = container.querySelector('.ice-cream-fill');
					const emptyIndicator = container.querySelector('.empty-indicator');
					
					if (iceCreamFill) {
						// Ensure ice cream has a random color before draining animation
						if (!iceCreamFill.dataset.colorSet || iceCreamFill.dataset.colorSet === 'false') {
							const randomColor = getRandomIceCreamColor();
							iceCreamFill.className = `ice-cream-fill absolute bottom-0 left-0 right-0 bg-gradient-to-t ${randomColor} transition-all duration-500 rounded-b-xl cursor-pointer`;
							iceCreamFill.dataset.colorSet = 'true';
						}
						// Animate ice cream "draining" as it's being eaten (works from any fill level)
						iceCreamFill.style.height = '20%';
						iceCreamFill.style.opacity = '0.4';
						iceCreamFill.style.transition = 'all 0.8s ease-in';
					}
					
					container.classList.add('animate-bounce');
					const iceCreamVisual = container.querySelector('.flex-shrink-0:first-child');
					iceCreamVisual.style.transform = 'scale(0.95) rotate(2deg)';
					iceCreamVisual.style.transition = 'all 0.5s ease-out';
					
					await new Promise(resolve => setTimeout(resolve, 500));
					
					// Phase 3: Complete ice cream disappearance
					if (iceCreamFill) {
						iceCreamFill.style.height = '0%';
						iceCreamFill.style.opacity = '0';
						iceCreamFill.style.transition = 'all 0.4s ease-out';
					}
					if (emptyIndicator) {
						emptyIndicator.style.opacity = '1';
						emptyIndicator.style.transition = 'opacity 0.4s ease-in 0.2s';
					}
					
					// Phase 4: Input field clear with fade effect
					input.style.transform = 'scale(0.9)';
					input.style.opacity = '0.3';
					input.style.transition = 'all 0.3s ease-out';
					
					await new Promise(resolve => setTimeout(resolve, 300));
					
					// Phase 5: Clear the flavor and show "Yum!" feedback
					input.value = '';
					containerFillLevels[containerId] = FILL_LEVELS.EMPTY; // Reset fill level
					if (iceCreamFill) {
						iceCreamFill.onclick = null; // Remove click handler
						// Reset color for next flavor
						iceCreamFill.dataset.colorSet = 'false';
					}
					eatBtn.innerHTML = 'üòã';
					
					// Phase 6: Show success message
					const originalBg = container.className;
					container.classList.add('ring-4', 'ring-green-200', 'ring-opacity-75');
					
					// Show temporary "Yum!" message
					const yumMessage = document.createElement('div');
					yumMessage.className = 'absolute top-2 right-2 bg-green-500 text-white px-3 py-1 rounded-full text-sm font-bold animate-bounce';
					yumMessage.textContent = '¬°√ëam!';
					yumMessage.style.zIndex = '50';
					container.style.position = 'relative';
					container.appendChild(yumMessage);
					
					await new Promise(resolve => setTimeout(resolve, 1500));
					
					// Phase 7: Reset everything (but keep visual state empty since ice cream was eaten)
					container.classList.remove('animate-bounce', 'ring-4', 'ring-green-200', 'ring-opacity-75');
					iceCreamVisual.style.transform = '';
					input.style.transform = '';
					input.style.opacity = '';
					eatBtn.classList.remove('animate-pulse');
					
					// Remove yum message
					if (yumMessage) {
						yumMessage.remove();
					}
					
					// Save the updated state
					saveFlavors();
					saveFillLevels(); // Save updated fill levels
					updateShareButton();
					updateEatButtons();
					
					console.log(`üòã Ice cream ${containerId} eaten!`);
					
				} catch (error) {
					console.error('‚ùå Error eating ice cream:', error);
					// Reset on error
					eatBtn.innerHTML = 'üòã';
					eatBtn.classList.remove('animate-pulse');
					eatBtn.disabled = false;
				}
			}

			// Initialize the app when DOM is loaded
			document.addEventListener('DOMContentLoaded', function() {
				// Add loading animation to main content
				const main = document.querySelector('main');
				main.style.opacity = '0';
				main.style.transform = 'translateY(20px)';
				
				setTimeout(() => {
					main.style.transition = 'all 0.6s ease-out';
					main.style.opacity = '1';
					main.style.transform = 'translateY(0)';
				}, 100);
				
				// Initialize Firebase session and load data
				initializeSession();
				
				// Add enhanced event listeners to all flavor inputs
				const inputs = document.querySelectorAll('.flavor-input');
				console.log(`üéØ Setting up event listeners for ${inputs.length} flavor inputs`);
				
				inputs.forEach((input, index) => {
					console.log(`üìù Setting up listeners for input ${index}: ${input.id}`);
					
					// Save on input (typing) with faster response
					input.addEventListener('input', (e) => {
						console.log(`‚å®Ô∏è Input event triggered on ${e.target.id}: "${e.target.value}"`);
						debouncedSave();
						updateShareButton();
						updateEatButtons();
						updateContainerVisuals(); // Immediate visual update
					});
					
					// Save immediately on blur (when user leaves the field)  
					input.addEventListener('blur', (e) => {
						console.log(`üëÅÔ∏è Blur event triggered on ${e.target.id}: "${e.target.value}"`);
						saveFlavors();
						saveFillLevels(); // Also save fill levels
						updateShareButton();
						updateEatButtons();
						updateContainerVisuals(); // Ensure visual state is correct
					});
					
					// Add focus enhancement
					input.addEventListener('focus', function() {
						this.parentElement.parentElement.classList.add('ring-2', 'ring-blue-200', 'ring-opacity-50');
					});
					
					input.addEventListener('blur', function() {
						this.parentElement.parentElement.classList.remove('ring-2', 'ring-blue-200', 'ring-opacity-50');
					});
				});
				
				// Add eat button event listeners
				const eatBtns = document.querySelectorAll('.eat-btn');
				eatBtns.forEach(btn => {
					btn.addEventListener('click', () => {
						const containerId = btn.dataset.container;
						eatIceCream(containerId);
					});
				});
				
				// Add share button event listener
				const shareBtn = document.getElementById('share-btn');
				if (shareBtn) {
					shareBtn.addEventListener('click', copyShareURL);
				}
				
				// Initial button state updates
				updateShareButton();
				updateEatButtons();
				
				console.log('üç¶ D√≥nde Est√° Mi Helado? initialized with enhanced UX and sharing');
			});

			// Save data and clean up listeners before page unload
			window.addEventListener('beforeunload', () => {
				// Clean up Firebase listeners
				if (firebaseListenersCleanup) {
					firebaseListenersCleanup();
				}
				// Final save
				saveFlavors();
			});
		</script>

		<!-- Custom CSS for additional animations -->
		<style>
			@keyframes fade-in {
				from {
					opacity: 0;
					transform: translateY(-10px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			@keyframes slide-up {
				from {
					opacity: 0;
					transform: translateY(30px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			.animate-fade-in {
				animation: fade-in 0.8s ease-out;
			}

			.animate-slide-up {
				animation: slide-up 0.6s ease-out 0.2s both;
			}

			/* Enhanced scroll behavior */
			html {
				scroll-behavior: smooth;
			}

			/* Custom focus styles for better accessibility */
			.flavor-input:focus {
				transform: translateY(-1px);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
			}

			/* Backdrop blur support fallback */
			@supports not (backdrop-filter: blur(12px)) {
				.backdrop-blur-sm {
					background: rgba(255, 255, 255, 0.9);
				}
			}
		</style>
	</body>
</html>
